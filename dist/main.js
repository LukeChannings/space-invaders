/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _virtualDom = __webpack_require__(1);\n\nvar _model = __webpack_require__(36);\n\nvar _model2 = _interopRequireDefault(_model);\n\nvar _view = __webpack_require__(57);\n\nvar _view2 = _interopRequireDefault(_view);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_model2.default.map(_view2.default).scan(function (_ref, nextTree) {\n  var _ref2 = _slicedToArray(_ref, 3);\n\n  var appNode = _ref2[0];\n  var currentTree = _ref2[1];\n  var patches = _ref2[2];\n  return !appNode ? [(0, _virtualDom.create)(nextTree), nextTree] : [appNode, nextTree, (0, _virtualDom.diff)(currentTree, nextTree)];\n}, []).onValue(function (app) {\n  if (!app[0].parentNode) {\n    document.body.appendChild(app[0]);\n  } else if (app[2]) {\n    (0, _virtualDom.patch)(app[0], app[2]);\n  }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=./src/main.js");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var diff = __webpack_require__(2)\r\nvar patch = __webpack_require__(15)\r\nvar h = __webpack_require__(24)\r\nvar create = __webpack_require__(35)\r\nvar VNode = __webpack_require__(26)\r\nvar VText = __webpack_require__(27)\r\n\r\nmodule.exports = {\r\n    diff: diff,\r\n    patch: patch,\r\n    h: h,\r\n    create: create,\r\n    VNode: VNode,\r\n    VText: VText\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/index.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/index.js");

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	eval("var diff = __webpack_require__(3)\n\nmodule.exports = diff\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/diff.js\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/diff.js");

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isArray = __webpack_require__(4)\n\nvar VPatch = __webpack_require__(5)\nvar isVNode = __webpack_require__(7)\nvar isVText = __webpack_require__(8)\nvar isWidget = __webpack_require__(9)\nvar isThunk = __webpack_require__(10)\nvar handleThunk = __webpack_require__(11)\n\nvar diffProps = __webpack_require__(12)\n\nmodule.exports = diff\n\nfunction diff(a, b) {\n    var patch = { a: a }\n    walk(a, b, patch, 0)\n    return patch\n}\n\nfunction walk(a, b, patch, index) {\n    if (a === b) {\n        return\n    }\n\n    var apply = patch[index]\n    var applyClear = false\n\n    if (isThunk(a) || isThunk(b)) {\n        thunks(a, b, patch, index)\n    } else if (b == null) {\n\n        // If a is a widget we will add a remove patch for it\n        // Otherwise any child widgets/hooks must be destroyed.\n        // This prevents adding two remove patches for a widget.\n        if (!isWidget(a)) {\n            clearState(a, patch, index)\n            apply = patch[index]\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))\n    } else if (isVNode(b)) {\n        if (isVNode(a)) {\n            if (a.tagName === b.tagName &&\n                a.namespace === b.namespace &&\n                a.key === b.key) {\n                var propsPatch = diffProps(a.properties, b.properties)\n                if (propsPatch) {\n                    apply = appendPatch(apply,\n                        new VPatch(VPatch.PROPS, a, propsPatch))\n                }\n                apply = diffChildren(a, b, patch, apply, index)\n            } else {\n                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n                applyClear = true\n            }\n        } else {\n            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))\n            applyClear = true\n        }\n    } else if (isVText(b)) {\n        if (!isVText(a)) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n            applyClear = true\n        } else if (a.text !== b.text) {\n            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))\n        }\n    } else if (isWidget(b)) {\n        if (!isWidget(a)) {\n            applyClear = true\n        }\n\n        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))\n    }\n\n    if (apply) {\n        patch[index] = apply\n    }\n\n    if (applyClear) {\n        clearState(a, patch, index)\n    }\n}\n\nfunction diffChildren(a, b, patch, apply, index) {\n    var aChildren = a.children\n    var orderedSet = reorder(aChildren, b.children)\n    var bChildren = orderedSet.children\n\n    var aLen = aChildren.length\n    var bLen = bChildren.length\n    var len = aLen > bLen ? aLen : bLen\n\n    for (var i = 0; i < len; i++) {\n        var leftNode = aChildren[i]\n        var rightNode = bChildren[i]\n        index += 1\n\n        if (!leftNode) {\n            if (rightNode) {\n                // Excess nodes in b need to be added\n                apply = appendPatch(apply,\n                    new VPatch(VPatch.INSERT, null, rightNode))\n            }\n        } else {\n            walk(leftNode, rightNode, patch, index)\n        }\n\n        if (isVNode(leftNode) && leftNode.count) {\n            index += leftNode.count\n        }\n    }\n\n    if (orderedSet.moves) {\n        // Reorder nodes last\n        apply = appendPatch(apply, new VPatch(\n            VPatch.ORDER,\n            a,\n            orderedSet.moves\n        ))\n    }\n\n    return apply\n}\n\nfunction clearState(vNode, patch, index) {\n    // TODO: Make this a single walk, not two\n    unhook(vNode, patch, index)\n    destroyWidgets(vNode, patch, index)\n}\n\n// Patch records for all destroyed widgets must be added because we need\n// a DOM node reference for the destroy function\nfunction destroyWidgets(vNode, patch, index) {\n    if (isWidget(vNode)) {\n        if (typeof vNode.destroy === \"function\") {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(VPatch.REMOVE, vNode, null)\n            )\n        }\n    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {\n        var children = vNode.children\n        var len = children.length\n        for (var i = 0; i < len; i++) {\n            var child = children[i]\n            index += 1\n\n            destroyWidgets(child, patch, index)\n\n            if (isVNode(child) && child.count) {\n                index += child.count\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\n// Create a sub-patch for thunks\nfunction thunks(a, b, patch, index) {\n    var nodes = handleThunk(a, b)\n    var thunkPatch = diff(nodes.a, nodes.b)\n    if (hasPatches(thunkPatch)) {\n        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)\n    }\n}\n\nfunction hasPatches(patch) {\n    for (var index in patch) {\n        if (index !== \"a\") {\n            return true\n        }\n    }\n\n    return false\n}\n\n// Execute hooks when two nodes are identical\nfunction unhook(vNode, patch, index) {\n    if (isVNode(vNode)) {\n        if (vNode.hooks) {\n            patch[index] = appendPatch(\n                patch[index],\n                new VPatch(\n                    VPatch.PROPS,\n                    vNode,\n                    undefinedKeys(vNode.hooks)\n                )\n            )\n        }\n\n        if (vNode.descendantHooks || vNode.hasThunks) {\n            var children = vNode.children\n            var len = children.length\n            for (var i = 0; i < len; i++) {\n                var child = children[i]\n                index += 1\n\n                unhook(child, patch, index)\n\n                if (isVNode(child) && child.count) {\n                    index += child.count\n                }\n            }\n        }\n    } else if (isThunk(vNode)) {\n        thunks(vNode, null, patch, index)\n    }\n}\n\nfunction undefinedKeys(obj) {\n    var result = {}\n\n    for (var key in obj) {\n        result[key] = undefined\n    }\n\n    return result\n}\n\n// List diff, naive left to right reordering\nfunction reorder(aChildren, bChildren) {\n    // O(M) time, O(M) memory\n    var bChildIndex = keyIndex(bChildren)\n    var bKeys = bChildIndex.keys\n    var bFree = bChildIndex.free\n\n    if (bFree.length === bChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(N) time, O(N) memory\n    var aChildIndex = keyIndex(aChildren)\n    var aKeys = aChildIndex.keys\n    var aFree = aChildIndex.free\n\n    if (aFree.length === aChildren.length) {\n        return {\n            children: bChildren,\n            moves: null\n        }\n    }\n\n    // O(MAX(N, M)) memory\n    var newChildren = []\n\n    var freeIndex = 0\n    var freeCount = bFree.length\n    var deletedItems = 0\n\n    // Iterate through a and match a node in b\n    // O(N) time,\n    for (var i = 0 ; i < aChildren.length; i++) {\n        var aItem = aChildren[i]\n        var itemIndex\n\n        if (aItem.key) {\n            if (bKeys.hasOwnProperty(aItem.key)) {\n                // Match up the old keys\n                itemIndex = bKeys[aItem.key]\n                newChildren.push(bChildren[itemIndex])\n\n            } else {\n                // Remove old keyed items\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        } else {\n            // Match the item in a with the next free item in b\n            if (freeIndex < freeCount) {\n                itemIndex = bFree[freeIndex++]\n                newChildren.push(bChildren[itemIndex])\n            } else {\n                // There are no free items in b to match with\n                // the free items in a, so the extra free nodes\n                // are deleted.\n                itemIndex = i - deletedItems++\n                newChildren.push(null)\n            }\n        }\n    }\n\n    var lastFreeIndex = freeIndex >= bFree.length ?\n        bChildren.length :\n        bFree[freeIndex]\n\n    // Iterate through b and append any new keys\n    // O(M) time\n    for (var j = 0; j < bChildren.length; j++) {\n        var newItem = bChildren[j]\n\n        if (newItem.key) {\n            if (!aKeys.hasOwnProperty(newItem.key)) {\n                // Add any new keyed items\n                // We are adding new items to the end and then sorting them\n                // in place. In future we should insert new items in place.\n                newChildren.push(newItem)\n            }\n        } else if (j >= lastFreeIndex) {\n            // Add any leftover non-keyed items\n            newChildren.push(newItem)\n        }\n    }\n\n    var simulate = newChildren.slice()\n    var simulateIndex = 0\n    var removes = []\n    var inserts = []\n    var simulateItem\n\n    for (var k = 0; k < bChildren.length;) {\n        var wantedItem = bChildren[k]\n        simulateItem = simulate[simulateIndex]\n\n        // remove items\n        while (simulateItem === null && simulate.length) {\n            removes.push(remove(simulate, simulateIndex, null))\n            simulateItem = simulate[simulateIndex]\n        }\n\n        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n            // if we need a key in this position...\n            if (wantedItem.key) {\n                if (simulateItem && simulateItem.key) {\n                    // if an insert doesn't put this key in place, it needs to move\n                    if (bKeys[simulateItem.key] !== k + 1) {\n                        removes.push(remove(simulate, simulateIndex, simulateItem.key))\n                        simulateItem = simulate[simulateIndex]\n                        // if the remove didn't put the wanted item in place, we need to insert it\n                        if (!simulateItem || simulateItem.key !== wantedItem.key) {\n                            inserts.push({key: wantedItem.key, to: k})\n                        }\n                        // items are matching, so skip ahead\n                        else {\n                            simulateIndex++\n                        }\n                    }\n                    else {\n                        inserts.push({key: wantedItem.key, to: k})\n                    }\n                }\n                else {\n                    inserts.push({key: wantedItem.key, to: k})\n                }\n                k++\n            }\n            // a key in simulate has no matching wanted key, remove it\n            else if (simulateItem && simulateItem.key) {\n                removes.push(remove(simulate, simulateIndex, simulateItem.key))\n            }\n        }\n        else {\n            simulateIndex++\n            k++\n        }\n    }\n\n    // remove all the remaining nodes from simulate\n    while(simulateIndex < simulate.length) {\n        simulateItem = simulate[simulateIndex]\n        removes.push(remove(simulate, simulateIndex, simulateItem && simulateItem.key))\n    }\n\n    // If the only moves we have are deletes then we can just\n    // let the delete patch remove these items.\n    if (removes.length === deletedItems && !inserts.length) {\n        return {\n            children: newChildren,\n            moves: null\n        }\n    }\n\n    return {\n        children: newChildren,\n        moves: {\n            removes: removes,\n            inserts: inserts\n        }\n    }\n}\n\nfunction remove(arr, index, key) {\n    arr.splice(index, 1)\n\n    return {\n        from: index,\n        key: key\n    }\n}\n\nfunction keyIndex(children) {\n    var keys = {}\n    var free = []\n    var length = children.length\n\n    for (var i = 0; i < length; i++) {\n        var child = children[i]\n\n        if (child.key) {\n            keys[child.key] = i\n        } else {\n            free.push(i)\n        }\n    }\n\n    return {\n        keys: keys,     // A hash of key name to index\n        free: free      // An array of unkeyed item indices\n    }\n}\n\nfunction appendPatch(apply, patch) {\n    if (apply) {\n        if (isArray(apply)) {\n            apply.push(patch)\n        } else {\n            apply = [apply, patch]\n        }\n\n        return apply\n    } else {\n        return patch\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vtree/diff.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vtree/diff.js");

/***/ },
/* 4 */
/***/ function(module, exports) {

	eval("var nativeIsArray = Array.isArray\nvar toString = Object.prototype.toString\n\nmodule.exports = nativeIsArray || isArray\n\nfunction isArray(obj) {\n    return toString.call(obj) === \"[object Array]\"\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/x-is-array/index.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=./~/x-is-array/index.js");

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	eval("var version = __webpack_require__(6)\n\nVirtualPatch.NONE = 0\nVirtualPatch.VTEXT = 1\nVirtualPatch.VNODE = 2\nVirtualPatch.WIDGET = 3\nVirtualPatch.PROPS = 4\nVirtualPatch.ORDER = 5\nVirtualPatch.INSERT = 6\nVirtualPatch.REMOVE = 7\nVirtualPatch.THUNK = 8\n\nmodule.exports = VirtualPatch\n\nfunction VirtualPatch(type, vNode, patch) {\n    this.type = Number(type)\n    this.vNode = vNode\n    this.patch = patch\n}\n\nVirtualPatch.prototype.version = version\nVirtualPatch.prototype.type = \"VirtualPatch\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vpatch.js\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/vpatch.js");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("module.exports = \"2\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/version.js\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/version.js");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("var version = __webpack_require__(6)\n\nmodule.exports = isVirtualNode\n\nfunction isVirtualNode(x) {\n    return x && x.type === \"VirtualNode\" && x.version === version\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vnode.js\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/is-vnode.js");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("var version = __webpack_require__(6)\n\nmodule.exports = isVirtualText\n\nfunction isVirtualText(x) {\n    return x && x.type === \"VirtualText\" && x.version === version\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vtext.js\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/is-vtext.js");

/***/ },
/* 9 */
/***/ function(module, exports) {

	eval("module.exports = isWidget\n\nfunction isWidget(w) {\n    return w && w.type === \"Widget\"\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-widget.js\n ** module id = 9\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/is-widget.js");

/***/ },
/* 10 */
/***/ function(module, exports) {

	eval("module.exports = isThunk\r\n\r\nfunction isThunk(t) {\r\n    return t && t.type === \"Thunk\"\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-thunk.js\n ** module id = 10\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/is-thunk.js");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isVNode = __webpack_require__(7)\nvar isVText = __webpack_require__(8)\nvar isWidget = __webpack_require__(9)\nvar isThunk = __webpack_require__(10)\n\nmodule.exports = handleThunk\n\nfunction handleThunk(a, b) {\n    var renderedA = a\n    var renderedB = b\n\n    if (isThunk(b)) {\n        renderedB = renderThunk(b, a)\n    }\n\n    if (isThunk(a)) {\n        renderedA = renderThunk(a, null)\n    }\n\n    return {\n        a: renderedA,\n        b: renderedB\n    }\n}\n\nfunction renderThunk(thunk, previous) {\n    var renderedThunk = thunk.vnode\n\n    if (!renderedThunk) {\n        renderedThunk = thunk.vnode = thunk.render(previous)\n    }\n\n    if (!(isVNode(renderedThunk) ||\n            isVText(renderedThunk) ||\n            isWidget(renderedThunk))) {\n        throw new Error(\"thunk did not return a valid node\");\n    }\n\n    return renderedThunk\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/handle-thunk.js\n ** module id = 11\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/handle-thunk.js");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(13)\nvar isHook = __webpack_require__(14)\n\nmodule.exports = diffProps\n\nfunction diffProps(a, b) {\n    var diff\n\n    for (var aKey in a) {\n        if (!(aKey in b)) {\n            diff = diff || {}\n            diff[aKey] = undefined\n        }\n\n        var aValue = a[aKey]\n        var bValue = b[aKey]\n\n        if (aValue === bValue) {\n            continue\n        } else if (isObject(aValue) && isObject(bValue)) {\n            if (getPrototype(bValue) !== getPrototype(aValue)) {\n                diff = diff || {}\n                diff[aKey] = bValue\n            } else if (isHook(bValue)) {\n                 diff = diff || {}\n                 diff[aKey] = bValue\n            } else {\n                var objectDiff = diffProps(aValue, bValue)\n                if (objectDiff) {\n                    diff = diff || {}\n                    diff[aKey] = objectDiff\n                }\n            }\n        } else {\n            diff = diff || {}\n            diff[aKey] = bValue\n        }\n    }\n\n    for (var bKey in b) {\n        if (!(bKey in a)) {\n            diff = diff || {}\n            diff[bKey] = b[bKey]\n        }\n    }\n\n    return diff\n}\n\nfunction getPrototype(value) {\n  if (Object.getPrototypeOf) {\n    return Object.getPrototypeOf(value)\n  } else if (value.__proto__) {\n    return value.__proto__\n  } else if (value.constructor) {\n    return value.constructor.prototype\n  }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vtree/diff-props.js\n ** module id = 12\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vtree/diff-props.js");

/***/ },
/* 13 */
/***/ function(module, exports) {

	eval("\"use strict\";\n\nmodule.exports = function isObject(x) {\n\treturn typeof x === \"object\" && x !== null;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/is-object/index.js\n ** module id = 13\n ** module chunks = 0\n **/\n//# sourceURL=./~/is-object/index.js");

/***/ },
/* 14 */
/***/ function(module, exports) {

	eval("module.exports = isHook\n\nfunction isHook(hook) {\n    return hook &&\n      (typeof hook.hook === \"function\" && !hook.hasOwnProperty(\"hook\") ||\n       typeof hook.unhook === \"function\" && !hook.hasOwnProperty(\"unhook\"))\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/is-vhook.js\n ** module id = 14\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/is-vhook.js");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("var patch = __webpack_require__(16)\n\nmodule.exports = patch\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/patch.js\n ** module id = 15\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/patch.js");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("var document = __webpack_require__(17)\nvar isArray = __webpack_require__(4)\n\nvar render = __webpack_require__(19)\nvar domIndex = __webpack_require__(21)\nvar patchOp = __webpack_require__(22)\nmodule.exports = patch\n\nfunction patch(rootNode, patches, renderOptions) {\n    renderOptions = renderOptions || {}\n    renderOptions.patch = renderOptions.patch && renderOptions.patch !== patch\n        ? renderOptions.patch\n        : patchRecursive\n    renderOptions.render = renderOptions.render || render\n\n    return renderOptions.patch(rootNode, patches, renderOptions)\n}\n\nfunction patchRecursive(rootNode, patches, renderOptions) {\n    var indices = patchIndices(patches)\n\n    if (indices.length === 0) {\n        return rootNode\n    }\n\n    var index = domIndex(rootNode, patches.a, indices)\n    var ownerDocument = rootNode.ownerDocument\n\n    if (!renderOptions.document && ownerDocument !== document) {\n        renderOptions.document = ownerDocument\n    }\n\n    for (var i = 0; i < indices.length; i++) {\n        var nodeIndex = indices[i]\n        rootNode = applyPatch(rootNode,\n            index[nodeIndex],\n            patches[nodeIndex],\n            renderOptions)\n    }\n\n    return rootNode\n}\n\nfunction applyPatch(rootNode, domNode, patchList, renderOptions) {\n    if (!domNode) {\n        return rootNode\n    }\n\n    var newNode\n\n    if (isArray(patchList)) {\n        for (var i = 0; i < patchList.length; i++) {\n            newNode = patchOp(patchList[i], domNode, renderOptions)\n\n            if (domNode === rootNode) {\n                rootNode = newNode\n            }\n        }\n    } else {\n        newNode = patchOp(patchList, domNode, renderOptions)\n\n        if (domNode === rootNode) {\n            rootNode = newNode\n        }\n    }\n\n    return rootNode\n}\n\nfunction patchIndices(patches) {\n    var indices = []\n\n    for (var key in patches) {\n        if (key !== \"a\") {\n            indices.push(Number(key))\n        }\n    }\n\n    return indices\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/patch.js\n ** module id = 16\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/patch.js");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {var topLevel = typeof global !== 'undefined' ? global :\n    typeof window !== 'undefined' ? window : {}\nvar minDoc = __webpack_require__(18);\n\nif (typeof document !== 'undefined') {\n    module.exports = document;\n} else {\n    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];\n\n    if (!doccy) {\n        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;\n    }\n\n    module.exports = doccy;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/global/document.js\n ** module id = 17\n ** module chunks = 0\n **/\n//# sourceURL=./~/global/document.js");

/***/ },
/* 18 */
/***/ function(module, exports) {

	eval("/* (ignored) */\n\n/*****************\n ** WEBPACK FOOTER\n ** min-document (ignored)\n ** module id = 18\n ** module chunks = 0\n **/\n//# sourceURL=min-document_(ignored)");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("var document = __webpack_require__(17)\n\nvar applyProperties = __webpack_require__(20)\n\nvar isVNode = __webpack_require__(7)\nvar isVText = __webpack_require__(8)\nvar isWidget = __webpack_require__(9)\nvar handleThunk = __webpack_require__(11)\n\nmodule.exports = createElement\n\nfunction createElement(vnode, opts) {\n    var doc = opts ? opts.document || document : document\n    var warn = opts ? opts.warn : null\n\n    vnode = handleThunk(vnode).a\n\n    if (isWidget(vnode)) {\n        return vnode.init()\n    } else if (isVText(vnode)) {\n        return doc.createTextNode(vnode.text)\n    } else if (!isVNode(vnode)) {\n        if (warn) {\n            warn(\"Item is not a valid virtual dom node\", vnode)\n        }\n        return null\n    }\n\n    var node = (vnode.namespace === null) ?\n        doc.createElement(vnode.tagName) :\n        doc.createElementNS(vnode.namespace, vnode.tagName)\n\n    var props = vnode.properties\n    applyProperties(node, props)\n\n    var children = vnode.children\n\n    for (var i = 0; i < children.length; i++) {\n        var childNode = createElement(children[i], opts)\n        if (childNode) {\n            node.appendChild(childNode)\n        }\n    }\n\n    return node\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/create-element.js\n ** module id = 19\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/create-element.js");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(13)\nvar isHook = __webpack_require__(14)\n\nmodule.exports = applyProperties\n\nfunction applyProperties(node, props, previous) {\n    for (var propName in props) {\n        var propValue = props[propName]\n\n        if (propValue === undefined) {\n            removeProperty(node, propName, propValue, previous);\n        } else if (isHook(propValue)) {\n            removeProperty(node, propName, propValue, previous)\n            if (propValue.hook) {\n                propValue.hook(node,\n                    propName,\n                    previous ? previous[propName] : undefined)\n            }\n        } else {\n            if (isObject(propValue)) {\n                patchObject(node, props, previous, propName, propValue);\n            } else {\n                node[propName] = propValue\n            }\n        }\n    }\n}\n\nfunction removeProperty(node, propName, propValue, previous) {\n    if (previous) {\n        var previousValue = previous[propName]\n\n        if (!isHook(previousValue)) {\n            if (propName === \"attributes\") {\n                for (var attrName in previousValue) {\n                    node.removeAttribute(attrName)\n                }\n            } else if (propName === \"style\") {\n                for (var i in previousValue) {\n                    node.style[i] = \"\"\n                }\n            } else if (typeof previousValue === \"string\") {\n                node[propName] = \"\"\n            } else {\n                node[propName] = null\n            }\n        } else if (previousValue.unhook) {\n            previousValue.unhook(node, propName, propValue)\n        }\n    }\n}\n\nfunction patchObject(node, props, previous, propName, propValue) {\n    var previousValue = previous ? previous[propName] : undefined\n\n    // Set attributes\n    if (propName === \"attributes\") {\n        for (var attrName in propValue) {\n            var attrValue = propValue[attrName]\n\n            if (attrValue === undefined) {\n                node.removeAttribute(attrName)\n            } else {\n                node.setAttribute(attrName, attrValue)\n            }\n        }\n\n        return\n    }\n\n    if(previousValue && isObject(previousValue) &&\n        getPrototype(previousValue) !== getPrototype(propValue)) {\n        node[propName] = propValue\n        return\n    }\n\n    if (!isObject(node[propName])) {\n        node[propName] = {}\n    }\n\n    var replacer = propName === \"style\" ? \"\" : undefined\n\n    for (var k in propValue) {\n        var value = propValue[k]\n        node[propName][k] = (value === undefined) ? replacer : value\n    }\n}\n\nfunction getPrototype(value) {\n    if (Object.getPrototypeOf) {\n        return Object.getPrototypeOf(value)\n    } else if (value.__proto__) {\n        return value.__proto__\n    } else if (value.constructor) {\n        return value.constructor.prototype\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/apply-properties.js\n ** module id = 20\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/apply-properties.js");

/***/ },
/* 21 */
/***/ function(module, exports) {

	eval("// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.\n// We don't want to read all of the DOM nodes in the tree so we use\n// the in-order tree indexing to eliminate recursion down certain branches.\n// We only recurse into a DOM node if we know that it contains a child of\n// interest.\n\nvar noChild = {}\n\nmodule.exports = domIndex\n\nfunction domIndex(rootNode, tree, indices, nodes) {\n    if (!indices || indices.length === 0) {\n        return {}\n    } else {\n        indices.sort(ascending)\n        return recurse(rootNode, tree, indices, nodes, 0)\n    }\n}\n\nfunction recurse(rootNode, tree, indices, nodes, rootIndex) {\n    nodes = nodes || {}\n\n\n    if (rootNode) {\n        if (indexInRange(indices, rootIndex, rootIndex)) {\n            nodes[rootIndex] = rootNode\n        }\n\n        var vChildren = tree.children\n\n        if (vChildren) {\n\n            var childNodes = rootNode.childNodes\n\n            for (var i = 0; i < tree.children.length; i++) {\n                rootIndex += 1\n\n                var vChild = vChildren[i] || noChild\n                var nextIndex = rootIndex + (vChild.count || 0)\n\n                // skip recursion down the tree if there are no nodes down here\n                if (indexInRange(indices, rootIndex, nextIndex)) {\n                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)\n                }\n\n                rootIndex = nextIndex\n            }\n        }\n    }\n\n    return nodes\n}\n\n// Binary search for an index in the interval [left, right]\nfunction indexInRange(indices, left, right) {\n    if (indices.length === 0) {\n        return false\n    }\n\n    var minIndex = 0\n    var maxIndex = indices.length - 1\n    var currentIndex\n    var currentItem\n\n    while (minIndex <= maxIndex) {\n        currentIndex = ((maxIndex + minIndex) / 2) >> 0\n        currentItem = indices[currentIndex]\n\n        if (minIndex === maxIndex) {\n            return currentItem >= left && currentItem <= right\n        } else if (currentItem < left) {\n            minIndex = currentIndex + 1\n        } else  if (currentItem > right) {\n            maxIndex = currentIndex - 1\n        } else {\n            return true\n        }\n    }\n\n    return false;\n}\n\nfunction ascending(a, b) {\n    return a > b ? 1 : -1\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/dom-index.js\n ** module id = 21\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/dom-index.js");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("var applyProperties = __webpack_require__(20)\n\nvar isWidget = __webpack_require__(9)\nvar VPatch = __webpack_require__(5)\n\nvar updateWidget = __webpack_require__(23)\n\nmodule.exports = applyPatch\n\nfunction applyPatch(vpatch, domNode, renderOptions) {\n    var type = vpatch.type\n    var vNode = vpatch.vNode\n    var patch = vpatch.patch\n\n    switch (type) {\n        case VPatch.REMOVE:\n            return removeNode(domNode, vNode)\n        case VPatch.INSERT:\n            return insertNode(domNode, patch, renderOptions)\n        case VPatch.VTEXT:\n            return stringPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.WIDGET:\n            return widgetPatch(domNode, vNode, patch, renderOptions)\n        case VPatch.VNODE:\n            return vNodePatch(domNode, vNode, patch, renderOptions)\n        case VPatch.ORDER:\n            reorderChildren(domNode, patch)\n            return domNode\n        case VPatch.PROPS:\n            applyProperties(domNode, patch, vNode.properties)\n            return domNode\n        case VPatch.THUNK:\n            return replaceRoot(domNode,\n                renderOptions.patch(domNode, patch, renderOptions))\n        default:\n            return domNode\n    }\n}\n\nfunction removeNode(domNode, vNode) {\n    var parentNode = domNode.parentNode\n\n    if (parentNode) {\n        parentNode.removeChild(domNode)\n    }\n\n    destroyWidget(domNode, vNode);\n\n    return null\n}\n\nfunction insertNode(parentNode, vNode, renderOptions) {\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode) {\n        parentNode.appendChild(newNode)\n    }\n\n    return parentNode\n}\n\nfunction stringPatch(domNode, leftVNode, vText, renderOptions) {\n    var newNode\n\n    if (domNode.nodeType === 3) {\n        domNode.replaceData(0, domNode.length, vText.text)\n        newNode = domNode\n    } else {\n        var parentNode = domNode.parentNode\n        newNode = renderOptions.render(vText, renderOptions)\n\n        if (parentNode && newNode !== domNode) {\n            parentNode.replaceChild(newNode, domNode)\n        }\n    }\n\n    return newNode\n}\n\nfunction widgetPatch(domNode, leftVNode, widget, renderOptions) {\n    var updating = updateWidget(leftVNode, widget)\n    var newNode\n\n    if (updating) {\n        newNode = widget.update(leftVNode, domNode) || domNode\n    } else {\n        newNode = renderOptions.render(widget, renderOptions)\n    }\n\n    var parentNode = domNode.parentNode\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    if (!updating) {\n        destroyWidget(domNode, leftVNode)\n    }\n\n    return newNode\n}\n\nfunction vNodePatch(domNode, leftVNode, vNode, renderOptions) {\n    var parentNode = domNode.parentNode\n    var newNode = renderOptions.render(vNode, renderOptions)\n\n    if (parentNode && newNode !== domNode) {\n        parentNode.replaceChild(newNode, domNode)\n    }\n\n    return newNode\n}\n\nfunction destroyWidget(domNode, w) {\n    if (typeof w.destroy === \"function\" && isWidget(w)) {\n        w.destroy(domNode)\n    }\n}\n\nfunction reorderChildren(domNode, moves) {\n    var childNodes = domNode.childNodes\n    var keyMap = {}\n    var node\n    var remove\n    var insert\n\n    for (var i = 0; i < moves.removes.length; i++) {\n        remove = moves.removes[i]\n        node = childNodes[remove.from]\n        if (remove.key) {\n            keyMap[remove.key] = node\n        }\n        domNode.removeChild(node)\n    }\n\n    var length = childNodes.length\n    for (var j = 0; j < moves.inserts.length; j++) {\n        insert = moves.inserts[j]\n        node = keyMap[insert.key]\n        // this is the weirdest bug i've ever seen in webkit\n        domNode.insertBefore(node, insert.to >= length++ ? null : childNodes[insert.to])\n    }\n}\n\nfunction replaceRoot(oldRoot, newRoot) {\n    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {\n        oldRoot.parentNode.replaceChild(newRoot, oldRoot)\n    }\n\n    return newRoot;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/patch-op.js\n ** module id = 22\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/patch-op.js");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isWidget = __webpack_require__(9)\n\nmodule.exports = updateWidget\n\nfunction updateWidget(a, b) {\n    if (isWidget(a) && isWidget(b)) {\n        if (\"name\" in a && \"name\" in b) {\n            return a.id === b.id\n        } else {\n            return a.init === b.init\n        }\n    }\n\n    return false\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vdom/update-widget.js\n ** module id = 23\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vdom/update-widget.js");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("var h = __webpack_require__(25)\n\nmodule.exports = h\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/h.js\n ** module id = 24\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/h.js");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar isArray = __webpack_require__(4);\n\nvar VNode = __webpack_require__(26);\nvar VText = __webpack_require__(27);\nvar isVNode = __webpack_require__(7);\nvar isVText = __webpack_require__(8);\nvar isWidget = __webpack_require__(9);\nvar isHook = __webpack_require__(14);\nvar isVThunk = __webpack_require__(10);\n\nvar parseTag = __webpack_require__(28);\nvar softSetHook = __webpack_require__(30);\nvar evHook = __webpack_require__(31);\n\nmodule.exports = h;\n\nfunction h(tagName, properties, children) {\n    var childNodes = [];\n    var tag, props, key, namespace;\n\n    if (!children && isChildren(properties)) {\n        children = properties;\n        props = {};\n    }\n\n    props = props || properties || {};\n    tag = parseTag(tagName, props);\n\n    // support keys\n    if (props.hasOwnProperty('key')) {\n        key = props.key;\n        props.key = undefined;\n    }\n\n    // support namespace\n    if (props.hasOwnProperty('namespace')) {\n        namespace = props.namespace;\n        props.namespace = undefined;\n    }\n\n    // fix cursor bug\n    if (tag === 'INPUT' &&\n        !namespace &&\n        props.hasOwnProperty('value') &&\n        props.value !== undefined &&\n        !isHook(props.value)\n    ) {\n        props.value = softSetHook(props.value);\n    }\n\n    transformProperties(props);\n\n    if (children !== undefined && children !== null) {\n        addChild(children, childNodes, tag, props);\n    }\n\n\n    return new VNode(tag, props, childNodes, key, namespace);\n}\n\nfunction addChild(c, childNodes, tag, props) {\n    if (typeof c === 'string') {\n        childNodes.push(new VText(c));\n    } else if (typeof c === 'number') {\n        childNodes.push(new VText(String(c)));\n    } else if (isChild(c)) {\n        childNodes.push(c);\n    } else if (isArray(c)) {\n        for (var i = 0; i < c.length; i++) {\n            addChild(c[i], childNodes, tag, props);\n        }\n    } else if (c === null || c === undefined) {\n        return;\n    } else {\n        throw UnexpectedVirtualElement({\n            foreignObject: c,\n            parentVnode: {\n                tagName: tag,\n                properties: props\n            }\n        });\n    }\n}\n\nfunction transformProperties(props) {\n    for (var propName in props) {\n        if (props.hasOwnProperty(propName)) {\n            var value = props[propName];\n\n            if (isHook(value)) {\n                continue;\n            }\n\n            if (propName.substr(0, 3) === 'ev-') {\n                // add ev-foo support\n                props[propName] = evHook(value);\n            }\n        }\n    }\n}\n\nfunction isChild(x) {\n    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);\n}\n\nfunction isChildren(x) {\n    return typeof x === 'string' || isArray(x) || isChild(x);\n}\n\nfunction UnexpectedVirtualElement(data) {\n    var err = new Error();\n\n    err.type = 'virtual-hyperscript.unexpected.virtual-element';\n    err.message = 'Unexpected virtual child passed to h().\\n' +\n        'Expected a VNode / Vthunk / VWidget / string but:\\n' +\n        'got:\\n' +\n        errorString(data.foreignObject) +\n        '.\\n' +\n        'The parent vnode is:\\n' +\n        errorString(data.parentVnode)\n        '\\n' +\n        'Suggested fix: change your `h(..., [ ... ])` callsite.';\n    err.foreignObject = data.foreignObject;\n    err.parentVnode = data.parentVnode;\n\n    return err;\n}\n\nfunction errorString(obj) {\n    try {\n        return JSON.stringify(obj, null, '    ');\n    } catch (e) {\n        return String(obj);\n    }\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/index.js\n ** module id = 25\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/virtual-hyperscript/index.js");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("var version = __webpack_require__(6)\nvar isVNode = __webpack_require__(7)\nvar isWidget = __webpack_require__(9)\nvar isThunk = __webpack_require__(10)\nvar isVHook = __webpack_require__(14)\n\nmodule.exports = VirtualNode\n\nvar noProperties = {}\nvar noChildren = []\n\nfunction VirtualNode(tagName, properties, children, key, namespace) {\n    this.tagName = tagName\n    this.properties = properties || noProperties\n    this.children = children || noChildren\n    this.key = key != null ? String(key) : undefined\n    this.namespace = (typeof namespace === \"string\") ? namespace : null\n\n    var count = (children && children.length) || 0\n    var descendants = 0\n    var hasWidgets = false\n    var hasThunks = false\n    var descendantHooks = false\n    var hooks\n\n    for (var propName in properties) {\n        if (properties.hasOwnProperty(propName)) {\n            var property = properties[propName]\n            if (isVHook(property) && property.unhook) {\n                if (!hooks) {\n                    hooks = {}\n                }\n\n                hooks[propName] = property\n            }\n        }\n    }\n\n    for (var i = 0; i < count; i++) {\n        var child = children[i]\n        if (isVNode(child)) {\n            descendants += child.count || 0\n\n            if (!hasWidgets && child.hasWidgets) {\n                hasWidgets = true\n            }\n\n            if (!hasThunks && child.hasThunks) {\n                hasThunks = true\n            }\n\n            if (!descendantHooks && (child.hooks || child.descendantHooks)) {\n                descendantHooks = true\n            }\n        } else if (!hasWidgets && isWidget(child)) {\n            if (typeof child.destroy === \"function\") {\n                hasWidgets = true\n            }\n        } else if (!hasThunks && isThunk(child)) {\n            hasThunks = true;\n        }\n    }\n\n    this.count = count + descendants\n    this.hasWidgets = hasWidgets\n    this.hasThunks = hasThunks\n    this.hooks = hooks\n    this.descendantHooks = descendantHooks\n}\n\nVirtualNode.prototype.version = version\nVirtualNode.prototype.type = \"VirtualNode\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vnode.js\n ** module id = 26\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/vnode.js");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var version = __webpack_require__(6)\n\nmodule.exports = VirtualText\n\nfunction VirtualText(text) {\n    this.text = String(text)\n}\n\nVirtualText.prototype.version = version\nVirtualText.prototype.type = \"VirtualText\"\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/vnode/vtext.js\n ** module id = 27\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/vnode/vtext.js");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar split = __webpack_require__(29);\n\nvar classIdSplit = /([\\.#]?[a-zA-Z0-9\\u007F-\\uFFFF_:-]+)/;\nvar notClassId = /^\\.|#/;\n\nmodule.exports = parseTag;\n\nfunction parseTag(tag, props) {\n    if (!tag) {\n        return 'DIV';\n    }\n\n    var noId = !(props.hasOwnProperty('id'));\n\n    var tagParts = split(tag, classIdSplit);\n    var tagName = null;\n\n    if (notClassId.test(tagParts[1])) {\n        tagName = 'DIV';\n    }\n\n    var classes, part, type, i;\n\n    for (i = 0; i < tagParts.length; i++) {\n        part = tagParts[i];\n\n        if (!part) {\n            continue;\n        }\n\n        type = part.charAt(0);\n\n        if (!tagName) {\n            tagName = part;\n        } else if (type === '.') {\n            classes = classes || [];\n            classes.push(part.substring(1, part.length));\n        } else if (type === '#' && noId) {\n            props.id = part.substring(1, part.length);\n        }\n    }\n\n    if (classes) {\n        if (props.className) {\n            classes.push(props.className);\n        }\n\n        props.className = classes.join(' ');\n    }\n\n    return props.namespace ? tagName : tagName.toUpperCase();\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/parse-tag.js\n ** module id = 28\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/virtual-hyperscript/parse-tag.js");

/***/ },
/* 29 */
/***/ function(module, exports) {

	eval("/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/browser-split/index.js\n ** module id = 29\n ** module chunks = 0\n **/\n//# sourceURL=./~/browser-split/index.js");

/***/ },
/* 30 */
/***/ function(module, exports) {

	eval("'use strict';\n\nmodule.exports = SoftSetHook;\n\nfunction SoftSetHook(value) {\n    if (!(this instanceof SoftSetHook)) {\n        return new SoftSetHook(value);\n    }\n\n    this.value = value;\n}\n\nSoftSetHook.prototype.hook = function (node, propertyName) {\n    if (node[propertyName] !== this.value) {\n        node[propertyName] = this.value;\n    }\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js\n ** module id = 30\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar EvStore = __webpack_require__(32);\n\nmodule.exports = EvHook;\n\nfunction EvHook(value) {\n    if (!(this instanceof EvHook)) {\n        return new EvHook(value);\n    }\n\n    this.value = value;\n}\n\nEvHook.prototype.hook = function (node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = this.value;\n};\n\nEvHook.prototype.unhook = function(node, propertyName) {\n    var es = EvStore(node);\n    var propName = propertyName.substr(3);\n\n    es[propName] = undefined;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/virtual-hyperscript/hooks/ev-hook.js\n ** module id = 31\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/virtual-hyperscript/hooks/ev-hook.js");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar OneVersionConstraint = __webpack_require__(33);\n\nvar MY_VERSION = '7';\nOneVersionConstraint('ev-store', MY_VERSION);\n\nvar hashKey = '__EV_STORE_KEY@' + MY_VERSION;\n\nmodule.exports = EvStore;\n\nfunction EvStore(elem) {\n    var hash = elem[hashKey];\n\n    if (!hash) {\n        hash = elem[hashKey] = {};\n    }\n\n    return hash;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ev-store/index.js\n ** module id = 32\n ** module chunks = 0\n **/\n//# sourceURL=./~/ev-store/index.js");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar Individual = __webpack_require__(34);\n\nmodule.exports = OneVersion;\n\nfunction OneVersion(moduleName, version, defaultValue) {\n    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;\n    var enforceKey = key + '_ENFORCE_SINGLETON';\n\n    var versionValue = Individual(enforceKey, version);\n\n    if (versionValue !== version) {\n        throw new Error('Can only have one copy of ' +\n            moduleName + '.\\n' +\n            'You already have version ' + versionValue +\n            ' installed.\\n' +\n            'This means you cannot install version ' + version);\n    }\n\n    return Individual(key, defaultValue);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/individual/one-version.js\n ** module id = 33\n ** module chunks = 0\n **/\n//# sourceURL=./~/individual/one-version.js");

/***/ },
/* 34 */
/***/ function(module, exports) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\n/*global window, global*/\n\nvar root = typeof window !== 'undefined' ?\n    window : typeof global !== 'undefined' ?\n    global : {};\n\nmodule.exports = Individual;\n\nfunction Individual(key, value) {\n    if (key in root) {\n        return root[key];\n    }\n\n    root[key] = value;\n\n    return value;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/individual/index.js\n ** module id = 34\n ** module chunks = 0\n **/\n//# sourceURL=./~/individual/index.js");

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	eval("var createElement = __webpack_require__(19)\n\nmodule.exports = createElement\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/virtual-dom/create-element.js\n ** module id = 35\n ** module chunks = 0\n **/\n//# sourceURL=./~/virtual-dom/create-element.js");

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _get2 = __webpack_require__(37);\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inRange2 = __webpack_require__(49);\n\nvar _inRange3 = _interopRequireDefault(_inRange2);\n\nvar _range2 = __webpack_require__(50);\n\nvar _range3 = _interopRequireDefault(_range2);\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _kefir = __webpack_require__(56);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar max = Math.max;\nvar min = Math.min;\nvar ceil = Math.ceil;\nvar floor = Math.floor;\n\n\nvar windowFocused$ = (0, _kefir.merge)([(0, _kefir.fromEvents)(window, 'blur').map(function () {\n  return false;\n}), (0, _kefir.fromEvents)(window, 'focus').map(function () {\n  return true;\n})]).toProperty(function () {\n  return true;\n});\n\nvar dimensions = function dimensions() {\n  return [window.innerWidth, window.innerHeight];\n};\nvar dimension$ = (0, _kefir.fromEvents)(window, 'resize').map(dimensions).toProperty(dimensions);\n\nvar fps = 60;\nvar fps$ = (0, _kefir.repeat)(function () {\n  return (0, _kefir.combine)([windowFocused$, (0, _kefir.interval)(1000 / fps)]).takeWhile(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 1);\n\n    var focused = _ref2[0];\n    return focused;\n  }).map(function () {\n    return global.performance.now();\n  }).diff(function (a, b) {\n    return b - a;\n  }).map(function (Δ) {\n    return Δ / 16;\n  });\n});\n// .take(1)\n\nvar keyDown$ = (0, _kefir.fromEvents)(window, 'keydown');\nvar keyUp$ = (0, _kefir.fromEvents)(window, 'keyup');\n\nvar makeKey$ = function makeKey$(_ref3) {\n  var key = _ref3.key;\n  var up = _ref3.up;\n  var down = _ref3.down;\n  var useΔ = _ref3.useΔ;\n  var useEvent = _ref3.useEvent;\n  return keyDown$.filter(function (e) {\n    return e.keyCode === key;\n  }).flatMapFirst(function (e) {\n    return fps$.map(function (Δ) {\n      return useΔ ? Δ : useEvent ? e : down;\n    }).takeUntilBy(keyUp$.filter(function (e) {\n      return e.keyCode === key;\n    }).map(function (e) {\n      return useΔ ? null : useEvent ? e : up;\n    }));\n  });\n};\n\nvar arrowDefault = { x: 0 };\n\nvar arrowLeft = { x: -1 };\nvar arrowLeft$ = makeKey$({\n  key: 37,\n  down: arrowLeft,\n  up: arrowDefault\n}).toProperty(function () {\n  return arrowDefault;\n});\n\nvar arrowRight = { x: 1 };\nvar arrowRight$ = makeKey$({\n  key: 39,\n  down: arrowRight,\n  up: arrowDefault\n}).toProperty(function () {\n  return arrowDefault;\n});\n\nvar cannon = { x: 50, lives: 3 };\nvar cannon$ = (0, _kefir.merge)([arrowLeft$, arrowRight$]).scan(function (cannon, _ref4) {\n  var x = _ref4.x;\n  return Object.assign({}, cannon, { x: min(100, max(0, cannon.x + x)) });\n}, cannon);\n\nvar firekeyFrequencyMs = 700;\nvar fireKey$ = makeKey$({ key: 38 }).throttle(firekeyFrequencyMs, { trailing: false }).map(function () {\n  return global.performance.now();\n});\n\nvar collision$ = (0, _kefir.pool)();\n\nvar cannonProjectiles = [{\n  x: 80,\n  y: 45,\n  id: performance.now()\n}];\nvar cannonProjectile$ = (0, _kefir.combine)([fps$, cannon$, fireKey$, collision$]).scan(function (cannonProjectiles, _ref5) {\n  var _ref6 = _slicedToArray(_ref5, 4);\n\n  var Δ = _ref6[0];\n  var cannon = _ref6[1];\n  var firedTime = _ref6[2];\n  var collision = _ref6[3];\n\n  var collisionId = (0, _get3.default)(collision, 'projectile.id', NaN);\n  var isNewProjectile = global.performance.now() - firedTime < 5 && !cannonProjectiles.filter(function (_ref7) {\n    var id = _ref7.id;\n    return firedTime === id;\n  }).length;\n\n  return [].concat(_toConsumableArray(isNewProjectile ? [{ id: firedTime, x: cannon.x, y: 0 }] : []), _toConsumableArray(cannonProjectiles.reduce(function (ps, p) {\n    return ceil(p.y) < 100 && p.id !== collisionId ? [].concat(_toConsumableArray(ps), [_extends({}, p, { y: p.y + Δ })]) : ps;\n  }, [])));\n}, cannonProjectiles);\n\nvar invaderDirection = 1;\nvar invaderSpeed = 90;\nvar invaderRowCount = 4;\nvar invadersPerRow = 11;\nvar invaderTopOffset = 20;\nvar invaderTypes = [{ type: 'small', points: 40, area: 3 }, { type: 'medium', points: 20, area: 4 }, { type: 'large', points: 10, area: 5 }];\n\nvar invaders = (0, _range3.default)(invaderRowCount * invadersPerRow).map(function (_, index) {\n  var column = index % invadersPerRow;\n  var row = floor(index / invadersPerRow);\n  return _extends({\n    id: index,\n    column: column,\n    x: 10 + column / (invadersPerRow - 1) * 80,\n    y: 100 - invaderTopOffset - row * 10\n  }, invaderTypes[[0, 1, 1, 2][row]]);\n});\n\nvar invaders$ = (0, _kefir.combine)([fps$, collision$]).scan(function (_ref8, _ref9) {\n  var _ref11 = _slicedToArray(_ref8, 2);\n\n  var invaders = _ref11[0];\n  var direction = _ref11[1];\n\n  var _ref10 = _slicedToArray(_ref9, 2);\n\n  var Δ = _ref10[0];\n  var collision = _ref10[1];\n\n  var columns = invaders.map(function (invader) {\n    return invader.column;\n  });\n  var hitAnEdge = !!invaders.filter(function (_ref12) {\n    var column = _ref12.column;\n    var x = _ref12.x;\n    return (column === min.apply(undefined, _toConsumableArray(columns)) || column === max.apply(undefined, _toConsumableArray(columns))) && (floor(x) === 0 || ceil(x) === 100);\n  }).length;\n\n  var direction_ = hitAnEdge ? +!direction : direction;\n\n  var invaders_ = (collision ? invaders.filter(function (_ref13) {\n    var id = _ref13.id;\n    return id !== collision.invader.id;\n  }) : invaders).map(function (invader) {\n    return _extends({}, invader, {\n      x: invader.x + (direction_ === 1 ? Δ : -Δ) / invaderSpeed\n    }, hitAnEdge ? { y: invader.y - 5 } : {});\n  });\n\n  return [invaders_, direction_];\n}, [invaders, invaderDirection]);\n\nvar score$ = collision$.scan(function (score, collision) {\n  return collision ? collision.invader.points + score : score;\n}, 0);\n\ncollision$.plug((0, _kefir.combine)([cannonProjectile$, dimension$, invaders$]).map(function (_ref14) {\n  var _ref15 = _slicedToArray(_ref14, 3);\n\n  var projectiles = _ref15[0];\n\n  var _ref15$ = _slicedToArray(_ref15[1], 2);\n\n  var width = _ref15$[0];\n  var height = _ref15$[1];\n\n  var _ref15$2 = _slicedToArray(_ref15[2], 1);\n\n  var invaders = _ref15$2[0];\n\n  if (projectiles.length) {\n    var collisions = invaders.reduce(function (collisions, invader) {\n      var projectilesWithHits = projectiles.filter(function (projectile) {\n        var offset = invader.area / 2;\n        if ((0, _inRange3.default)(projectile.x, floor(invader.x - offset), ceil(invader.x + offset)) && (0, _inRange3.default)(projectile.y, floor(invader.y - invader.area), ceil(invader.y))) {\n          console.log(projectile, invader);\n          return true;\n        }\n      });\n\n      var collision = projectilesWithHits.length && { invader: invader, projectile: projectilesWithHits[0] };\n\n      return collision ? collisions.concat(collision) : collisions;\n    }, []);\n\n    if (collisions.length) {\n      return collisions[0];\n    }\n  }\n  return false;\n}).sampledBy(fps$));\n\nexports.default = (0, _kefir.combine)([dimension$, cannon$, cannonProjectile$, invaders$, score$], function () {\n  for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {\n    data[_key] = arguments[_key];\n  }\n\n  return {\n    dimensions: {\n      width: data[0][0],\n      height: data[0][1]\n    },\n    cannon: data[1],\n    cannonProjectiles: data[2],\n    invaders: data[3][0],\n    score: data[4]\n  };\n});\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/model.js\n ** module id = 36\n ** module chunks = 0\n **/\n//# sourceURL=./src/model.js");

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseGet = __webpack_require__(38),\n    toPath = __webpack_require__(41);\n\n/**\n * Gets the property value at `path` of `object`. If the resolved value is\n * `undefined` the `defaultValue` is used in its place.\n *\n * @static\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned if the resolved value is `undefined`.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, toPath(path), (path + ''));\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/object/get.js\n ** module id = 37\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/object/get.js");

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	eval("var toObject = __webpack_require__(39);\n\n/**\n * The base implementation of `get` without support for string paths\n * and default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array} path The path of the property to get.\n * @param {string} [pathKey] The key representation of path.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path, pathKey) {\n  if (object == null) {\n    return;\n  }\n  if (pathKey !== undefined && pathKey in toObject(object)) {\n    path = [pathKey];\n  }\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[path[index++]];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseGet.js\n ** module id = 38\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/baseGet.js");

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(40);\n\n/**\n * Converts `value` to an object if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Object} Returns the object.\n */\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/toObject.js\n ** module id = 39\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/toObject.js");

/***/ },
/* 40 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.\n * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(1);\n * // => false\n */\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isObject.js\n ** module id = 40\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/lang/isObject.js");

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseToString = __webpack_require__(42),\n    isArray = __webpack_require__(43);\n\n/** Used to match property names within property paths. */\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\n\\\\]|\\\\.)*?)\\2)\\]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/**\n * Converts `value` to property path array if it's not one.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {Array} Returns the property path array.\n */\nfunction toPath(value) {\n  if (isArray(value)) {\n    return value;\n  }\n  var result = [];\n  baseToString(value).replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n}\n\nmodule.exports = toPath;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/toPath.js\n ** module id = 41\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/toPath.js");

/***/ },
/* 42 */
/***/ function(module, exports) {

	eval("/**\n * Converts `value` to a string if it's not one. An empty string is returned\n * for `null` or `undefined` values.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  return value == null ? '' : (value + '');\n}\n\nmodule.exports = baseToString;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseToString.js\n ** module id = 42\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/baseToString.js");

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getNative = __webpack_require__(44),\n    isLength = __webpack_require__(48),\n    isObjectLike = __webpack_require__(47);\n\n/** `Object#toString` result references. */\nvar arrayTag = '[object Array]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeIsArray = getNative(Array, 'isArray');\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(function() { return arguments; }());\n * // => false\n */\nvar isArray = nativeIsArray || function(value) {\n  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;\n};\n\nmodule.exports = isArray;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isArray.js\n ** module id = 43\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/lang/isArray.js");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isNative = __webpack_require__(45);\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = object == null ? undefined : object[key];\n  return isNative(value) ? value : undefined;\n}\n\nmodule.exports = getNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/getNative.js\n ** module id = 44\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/getNative.js");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isFunction = __webpack_require__(46),\n    isObjectLike = __webpack_require__(47);\n\n/** Used to detect host constructors (Safari > 5). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar fnToString = Function.prototype.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  fnToString.call(hasOwnProperty).replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/**\n * Checks if `value` is a native function.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function, else `false`.\n * @example\n *\n * _.isNative(Array.prototype.push);\n * // => true\n *\n * _.isNative(_);\n * // => false\n */\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (isFunction(value)) {\n    return reIsNative.test(fnToString.call(value));\n  }\n  return isObjectLike(value) && reIsHostCtor.test(value);\n}\n\nmodule.exports = isNative;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isNative.js\n ** module id = 45\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/lang/isNative.js");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isObject = __webpack_require__(40);\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]';\n\n/** Used for native method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objToString = objectProto.toString;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in older versions of Chrome and Safari which return 'function' for regexes\n  // and Safari 8 which returns 'object' for typed array constructors.\n  return isObject(value) && objToString.call(value) == funcTag;\n}\n\nmodule.exports = isFunction;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/lang/isFunction.js\n ** module id = 46\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/lang/isFunction.js");

/***/ },
/* 47 */
/***/ function(module, exports) {

	eval("/**\n * Checks if `value` is object-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isObjectLike.js\n ** module id = 47\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/isObjectLike.js");

/***/ },
/* 48 */
/***/ function(module, exports) {

	eval("/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n */\nfunction isLength(value) {\n  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isLength.js\n ** module id = 48\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/isLength.js");

/***/ },
/* 49 */
/***/ function(module, exports) {

	eval("/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Checks if `n` is between `start` and up to but not including, `end`. If\n * `end` is not specified it's set to `start` with `start` then set to `0`.\n *\n * @static\n * @memberOf _\n * @category Number\n * @param {number} n The number to check.\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @returns {boolean} Returns `true` if `n` is in the range, else `false`.\n * @example\n *\n * _.inRange(3, 2, 4);\n * // => true\n *\n * _.inRange(4, 8);\n * // => true\n *\n * _.inRange(4, 2);\n * // => false\n *\n * _.inRange(2, 2);\n * // => false\n *\n * _.inRange(1.2, 2);\n * // => true\n *\n * _.inRange(5.2, 4);\n * // => false\n */\nfunction inRange(value, start, end) {\n  start = +start || 0;\n  if (end === undefined) {\n    end = start;\n    start = 0;\n  } else {\n    end = +end || 0;\n  }\n  return value >= nativeMin(start, end) && value < nativeMax(start, end);\n}\n\nmodule.exports = inRange;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/number/inRange.js\n ** module id = 49\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/number/inRange.js");

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isIterateeCall = __webpack_require__(51);\n\n/* Native method references for those with the same name as other `lodash` methods. */\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n\n/**\n * Creates an array of numbers (positive and/or negative) progressing from\n * `start` up to, but not including, `end`. If `end` is not specified it's\n * set to `start` with `start` then set to `0`. If `end` is less than `start`\n * a zero-length range is created unless a negative `step` is specified.\n *\n * @static\n * @memberOf _\n * @category Utility\n * @param {number} [start=0] The start of the range.\n * @param {number} end The end of the range.\n * @param {number} [step=1] The value to increment or decrement by.\n * @returns {Array} Returns the new array of numbers.\n * @example\n *\n * _.range(4);\n * // => [0, 1, 2, 3]\n *\n * _.range(1, 5);\n * // => [1, 2, 3, 4]\n *\n * _.range(0, 20, 5);\n * // => [0, 5, 10, 15]\n *\n * _.range(0, -4, -1);\n * // => [0, -1, -2, -3]\n *\n * _.range(1, 4, 0);\n * // => [1, 1, 1]\n *\n * _.range(0);\n * // => []\n */\nfunction range(start, end, step) {\n  if (step && isIterateeCall(start, end, step)) {\n    end = step = undefined;\n  }\n  start = +start || 0;\n  step = step == null ? 1 : (+step || 0);\n\n  if (end == null) {\n    end = start;\n    start = 0;\n  } else {\n    end = +end || 0;\n  }\n  // Use `Array(length)` so engines like Chakra and V8 avoid slower modes.\n  // See https://youtu.be/XAqIpGU8ZZk#t=17m25s for more details.\n  var index = -1,\n      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = start;\n    start += step;\n  }\n  return result;\n}\n\nmodule.exports = range;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/utility/range.js\n ** module id = 50\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/utility/range.js");

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("var isArrayLike = __webpack_require__(52),\n    isIndex = __webpack_require__(55),\n    isObject = __webpack_require__(40);\n\n/**\n * Checks if the provided arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n      ? (isArrayLike(object) && isIndex(index, object.length))\n      : (type == 'string' && index in object)) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isIterateeCall.js\n ** module id = 51\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/isIterateeCall.js");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("var getLength = __webpack_require__(53),\n    isLength = __webpack_require__(48);\n\n/**\n * Checks if `value` is array-like.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(getLength(value));\n}\n\nmodule.exports = isArrayLike;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isArrayLike.js\n ** module id = 52\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/isArrayLike.js");

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	eval("var baseProperty = __webpack_require__(54);\n\n/**\n * Gets the \"length\" property value of `object`.\n *\n * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)\n * that affects Safari on at least iOS 8.1-8.3 ARM64.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {*} Returns the \"length\" value.\n */\nvar getLength = baseProperty('length');\n\nmodule.exports = getLength;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/getLength.js\n ** module id = 53\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/getLength.js");

/***/ },
/* 54 */
/***/ function(module, exports) {

	eval("/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/baseProperty.js\n ** module id = 54\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/baseProperty.js");

/***/ },
/* 55 */
/***/ function(module, exports) {

	eval("/** Used to detect unsigned integer values. */\nvar reIsUint = /^\\d+$/;\n\n/**\n * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)\n * of an array-like value.\n */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lodash/internal/isIndex.js\n ** module id = 55\n ** module chunks = 0\n **/\n//# sourceURL=./~/lodash/internal/isIndex.js");

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*! Kefir.js v3.2.1\n *  https://github.com/rpominov/kefir\n */\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.Kefir = global.Kefir || {})));\n}(this, function (exports) { 'use strict';\n\n  function createObj(proto) {\n    var F = function () {};\n    F.prototype = proto;\n    return new F();\n  }\n\n  function extend(target /*, mixin1, mixin2...*/) {\n    var length = arguments.length,\n        i = undefined,\n        prop = undefined;\n    for (i = 1; i < length; i++) {\n      for (prop in arguments[i]) {\n        target[prop] = arguments[i][prop];\n      }\n    }\n    return target;\n  }\n\n  function inherit(Child, Parent /*, mixin1, mixin2...*/) {\n    var length = arguments.length,\n        i = undefined;\n    Child.prototype = createObj(Parent.prototype);\n    Child.prototype.constructor = Child;\n    for (i = 2; i < length; i++) {\n      extend(Child.prototype, arguments[i]);\n    }\n    return Child;\n  }\n\n  var NOTHING = ['<nothing>'];\n  var END = 'end';\n  var VALUE = 'value';\n  var ERROR = 'error';\n  var ANY = 'any';\n\n  function concat(a, b) {\n    var result = undefined,\n        length = undefined,\n        i = undefined,\n        j = undefined;\n    if (a.length === 0) {\n      return b;\n    }\n    if (b.length === 0) {\n      return a;\n    }\n    j = 0;\n    result = new Array(a.length + b.length);\n    length = a.length;\n    for (i = 0; i < length; i++, j++) {\n      result[j] = a[i];\n    }\n    length = b.length;\n    for (i = 0; i < length; i++, j++) {\n      result[j] = b[i];\n    }\n    return result;\n  }\n\n  function find(arr, value) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      if (arr[i] === value) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function findByPred(arr, pred) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      if (pred(arr[i])) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  function cloneArray(input) {\n    var length = input.length,\n        result = new Array(length),\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      result[i] = input[i];\n    }\n    return result;\n  }\n\n  function remove(input, index) {\n    var length = input.length,\n        result = undefined,\n        i = undefined,\n        j = undefined;\n    if (index >= 0 && index < length) {\n      if (length === 1) {\n        return [];\n      } else {\n        result = new Array(length - 1);\n        for (i = 0, j = 0; i < length; i++) {\n          if (i !== index) {\n            result[j] = input[i];\n            j++;\n          }\n        }\n        return result;\n      }\n    } else {\n      return input;\n    }\n  }\n\n  function map(input, fn) {\n    var length = input.length,\n        result = new Array(length),\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      result[i] = fn(input[i]);\n    }\n    return result;\n  }\n\n  function forEach(arr, fn) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      fn(arr[i]);\n    }\n  }\n\n  function fillArray(arr, value) {\n    var length = arr.length,\n        i = undefined;\n    for (i = 0; i < length; i++) {\n      arr[i] = value;\n    }\n  }\n\n  function contains(arr, value) {\n    return find(arr, value) !== -1;\n  }\n\n  function slide(cur, next, max) {\n    var length = Math.min(max, cur.length + 1),\n        offset = cur.length - length + 1,\n        result = new Array(length),\n        i = undefined;\n    for (i = offset; i < length; i++) {\n      result[i - offset] = cur[i];\n    }\n    result[length - 1] = next;\n    return result;\n  }\n\n  function callSubscriber(type, fn, event) {\n    if (type === ANY) {\n      fn(event);\n    } else if (type === event.type) {\n      if (type === VALUE || type === ERROR) {\n        fn(event.value);\n      } else {\n        fn();\n      }\n    }\n  }\n\n  function Dispatcher() {\n    this._items = [];\n    this._inLoop = 0;\n    this._removedItems = null;\n  }\n\n  extend(Dispatcher.prototype, {\n    add: function (type, fn) {\n      this._items = concat(this._items, [{ type: type, fn: fn }]);\n      return this._items.length;\n    },\n    remove: function (type, fn) {\n      var index = findByPred(this._items, function (x) {\n        return x.type === type && x.fn === fn;\n      });\n\n      // if we're currently in a notification loop,\n      // remember this subscriber was removed\n      if (this._inLoop !== 0 && index !== -1) {\n        if (this._removedItems === null) {\n          this._removedItems = [];\n        }\n        this._removedItems.push(this._items[index]);\n      }\n\n      this._items = remove(this._items, index);\n      return this._items.length;\n    },\n    dispatch: function (event) {\n      this._inLoop++;\n      for (var i = 0, items = this._items; i < items.length; i++) {\n\n        // cleanup was called\n        if (this._items === null) {\n          break;\n        }\n\n        // this subscriber was removed\n        if (this._removedItems !== null && contains(this._removedItems, items[i])) {\n          continue;\n        }\n\n        callSubscriber(items[i].type, items[i].fn, event);\n      }\n      this._inLoop--;\n      if (this._inLoop === 0) {\n        this._removedItems = null;\n      }\n    },\n    cleanup: function () {\n      this._items = null;\n    }\n  });\n\n  function Observable() {\n    this._dispatcher = new Dispatcher();\n    this._active = false;\n    this._alive = true;\n    this._activating = false;\n    this._logHandlers = null;\n  }\n\n  extend(Observable.prototype, {\n\n    _name: 'observable',\n\n    _onActivation: function () {},\n    _onDeactivation: function () {},\n    _setActive: function (active) {\n      if (this._active !== active) {\n        this._active = active;\n        if (active) {\n          this._activating = true;\n          this._onActivation();\n          this._activating = false;\n        } else {\n          this._onDeactivation();\n        }\n      }\n    },\n    _clear: function () {\n      this._setActive(false);\n      this._dispatcher.cleanup();\n      this._dispatcher = null;\n      this._logHandlers = null;\n    },\n    _emit: function (type, x) {\n      switch (type) {\n        case VALUE:\n          return this._emitValue(x);\n        case ERROR:\n          return this._emitError(x);\n        case END:\n          return this._emitEnd();\n      }\n    },\n    _emitValue: function (value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({ type: VALUE, value: value });\n      }\n    },\n    _emitError: function (value) {\n      if (this._alive) {\n        this._dispatcher.dispatch({ type: ERROR, value: value });\n      }\n    },\n    _emitEnd: function () {\n      if (this._alive) {\n        this._alive = false;\n        this._dispatcher.dispatch({ type: END });\n        this._clear();\n      }\n    },\n    _on: function (type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n        this._setActive(true);\n      } else {\n        callSubscriber(type, fn, { type: END });\n      }\n      return this;\n    },\n    _off: function (type, fn) {\n      if (this._alive) {\n        var count = this._dispatcher.remove(type, fn);\n        if (count === 0) {\n          this._setActive(false);\n        }\n      }\n      return this;\n    },\n    onValue: function (fn) {\n      return this._on(VALUE, fn);\n    },\n    onError: function (fn) {\n      return this._on(ERROR, fn);\n    },\n    onEnd: function (fn) {\n      return this._on(END, fn);\n    },\n    onAny: function (fn) {\n      return this._on(ANY, fn);\n    },\n    offValue: function (fn) {\n      return this._off(VALUE, fn);\n    },\n    offError: function (fn) {\n      return this._off(ERROR, fn);\n    },\n    offEnd: function (fn) {\n      return this._off(END, fn);\n    },\n    offAny: function (fn) {\n      return this._off(ANY, fn);\n    },\n\n\n    // A and B must be subclasses of Stream and Property (order doesn't matter)\n    _ofSameType: function (A, B) {\n      return A.prototype.getType() === this.getType() ? A : B;\n    },\n    setName: function (sourceObs /* optional */, selfName) {\n      this._name = selfName ? sourceObs._name + '.' + selfName : sourceObs;\n      return this;\n    },\n    log: function () {\n      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\n\n      var isCurrent = undefined;\n      var handler = function (event) {\n        var type = '<' + event.type + (isCurrent ? ':current' : '') + '>';\n        if (event.type === END) {\n          console.log(name, type);\n        } else {\n          console.log(name, type, event.value);\n        }\n      };\n\n      if (this._alive) {\n        if (!this._logHandlers) {\n          this._logHandlers = [];\n        }\n        this._logHandlers.push({ name: name, handler: handler });\n      }\n\n      isCurrent = true;\n      this.onAny(handler);\n      isCurrent = false;\n\n      return this;\n    },\n    offLog: function () {\n      var name = arguments.length <= 0 || arguments[0] === undefined ? this.toString() : arguments[0];\n\n\n      if (this._logHandlers) {\n        var handlerIndex = findByPred(this._logHandlers, function (obj) {\n          return obj.name === name;\n        });\n        if (handlerIndex !== -1) {\n          this.offAny(this._logHandlers[handlerIndex].handler);\n          this._logHandlers.splice(handlerIndex, 1);\n        }\n      }\n\n      return this;\n    }\n  });\n\n  // extend() can't handle `toString` in IE8\n  Observable.prototype.toString = function () {\n    return '[' + this._name + ']';\n  };\n\n  function Stream() {\n    Observable.call(this);\n  }\n\n  inherit(Stream, Observable, {\n\n    _name: 'stream',\n\n    getType: function () {\n      return 'stream';\n    }\n  });\n\n  function Property() {\n    Observable.call(this);\n    this._currentEvent = null;\n  }\n\n  inherit(Property, Observable, {\n\n    _name: 'property',\n\n    _emitValue: function (value) {\n      if (this._alive) {\n        this._currentEvent = { type: VALUE, value: value };\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: VALUE, value: value });\n        }\n      }\n    },\n    _emitError: function (value) {\n      if (this._alive) {\n        this._currentEvent = { type: ERROR, value: value };\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: ERROR, value: value });\n        }\n      }\n    },\n    _emitEnd: function () {\n      if (this._alive) {\n        this._alive = false;\n        if (!this._activating) {\n          this._dispatcher.dispatch({ type: END });\n        }\n        this._clear();\n      }\n    },\n    _on: function (type, fn) {\n      if (this._alive) {\n        this._dispatcher.add(type, fn);\n        this._setActive(true);\n      }\n      if (this._currentEvent !== null) {\n        callSubscriber(type, fn, this._currentEvent);\n      }\n      if (!this._alive) {\n        callSubscriber(type, fn, { type: END });\n      }\n      return this;\n    },\n    getType: function () {\n      return 'property';\n    }\n  });\n\n  var neverS = new Stream();\n  neverS._emitEnd();\n  neverS._name = 'never';\n\n  function never() {\n    return neverS;\n  }\n\n  function timeBased(mixin) {\n\n    function AnonymousStream(wait, options) {\n      var _this = this;\n\n      Stream.call(this);\n      this._wait = wait;\n      this._intervalId = null;\n      this._$onTick = function () {\n        return _this._onTick();\n      };\n      this._init(options);\n    }\n\n    inherit(AnonymousStream, Stream, {\n      _init: function () {},\n      _free: function () {},\n      _onTick: function () {},\n      _onActivation: function () {\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      },\n      _onDeactivation: function () {\n        if (this._intervalId !== null) {\n          clearInterval(this._intervalId);\n          this._intervalId = null;\n        }\n      },\n      _clear: function () {\n        Stream.prototype._clear.call(this);\n        this._$onTick = null;\n        this._free();\n      }\n    }, mixin);\n\n    return AnonymousStream;\n  }\n\n  var S = timeBased({\n\n    _name: 'later',\n\n    _init: function (_ref) {\n      var x = _ref.x;\n\n      this._x = x;\n    },\n    _free: function () {\n      this._x = null;\n    },\n    _onTick: function () {\n      this._emitValue(this._x);\n      this._emitEnd();\n    }\n  });\n\n  function later(wait, x) {\n    return new S(wait, { x: x });\n  }\n\n  var S$1 = timeBased({\n\n    _name: 'interval',\n\n    _init: function (_ref) {\n      var x = _ref.x;\n\n      this._x = x;\n    },\n    _free: function () {\n      this._x = null;\n    },\n    _onTick: function () {\n      this._emitValue(this._x);\n    }\n  });\n\n  function interval(wait, x) {\n    return new S$1(wait, { x: x });\n  }\n\n  var S$2 = timeBased({\n\n    _name: 'sequentially',\n\n    _init: function (_ref) {\n      var xs = _ref.xs;\n\n      this._xs = cloneArray(xs);\n    },\n    _free: function () {\n      this._xs = null;\n    },\n    _onTick: function () {\n      if (this._xs.length === 1) {\n        this._emitValue(this._xs[0]);\n        this._emitEnd();\n      } else {\n        this._emitValue(this._xs.shift());\n      }\n    }\n  });\n\n  function sequentially(wait, xs) {\n    return xs.length === 0 ? never() : new S$2(wait, { xs: xs });\n  }\n\n  var S$3 = timeBased({\n\n    _name: 'fromPoll',\n\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _onTick: function () {\n      var fn = this._fn;\n      this._emitValue(fn());\n    }\n  });\n\n  function fromPoll(wait, fn) {\n    return new S$3(wait, { fn: fn });\n  }\n\n  function emitter(obs) {\n\n    function value(x) {\n      obs._emitValue(x);\n      return obs._active;\n    }\n\n    function error(x) {\n      obs._emitError(x);\n      return obs._active;\n    }\n\n    function end() {\n      obs._emitEnd();\n      return obs._active;\n    }\n\n    function event(e) {\n      obs._emit(e.type, e.value);\n      return obs._active;\n    }\n\n    return { value: value, error: error, end: end, event: event, emit: value, emitEvent: event };\n  }\n\n  var S$4 = timeBased({\n\n    _name: 'withInterval',\n\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function () {\n      this._fn = null;\n      this._emitter = null;\n    },\n    _onTick: function () {\n      var fn = this._fn;\n      fn(this._emitter);\n    }\n  });\n\n  function withInterval(wait, fn) {\n    return new S$4(wait, { fn: fn });\n  }\n\n  function S$5(fn) {\n    Stream.call(this);\n    this._fn = fn;\n    this._unsubscribe = null;\n  }\n\n  inherit(S$5, Stream, {\n\n    _name: 'stream',\n\n    _onActivation: function () {\n      var fn = this._fn;\n      var unsubscribe = fn(emitter(this));\n      this._unsubscribe = typeof unsubscribe === 'function' ? unsubscribe : null;\n\n      // fix https://github.com/rpominov/kefir/issues/35\n      if (!this._active) {\n        this._callUnsubscribe();\n      }\n    },\n    _callUnsubscribe: function () {\n      if (this._unsubscribe !== null) {\n        this._unsubscribe();\n        this._unsubscribe = null;\n      }\n    },\n    _onDeactivation: function () {\n      this._callUnsubscribe();\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._fn = null;\n    }\n  });\n\n  function stream(fn) {\n    return new S$5(fn);\n  }\n\n  function fromCallback(callbackConsumer) {\n\n    var called = false;\n\n    return stream(function (emitter) {\n\n      if (!called) {\n        callbackConsumer(function (x) {\n          emitter.emit(x);\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromCallback');\n  }\n\n  function fromNodeCallback(callbackConsumer) {\n\n    var called = false;\n\n    return stream(function (emitter) {\n\n      if (!called) {\n        callbackConsumer(function (error, x) {\n          if (error) {\n            emitter.error(error);\n          } else {\n            emitter.emit(x);\n          }\n          emitter.end();\n        });\n        called = true;\n      }\n    }).setName('fromNodeCallback');\n  }\n\n  function spread(fn, length) {\n    switch (length) {\n      case 0:\n        return function () {\n          return fn();\n        };\n      case 1:\n        return function (a) {\n          return fn(a[0]);\n        };\n      case 2:\n        return function (a) {\n          return fn(a[0], a[1]);\n        };\n      case 3:\n        return function (a) {\n          return fn(a[0], a[1], a[2]);\n        };\n      case 4:\n        return function (a) {\n          return fn(a[0], a[1], a[2], a[3]);\n        };\n      default:\n        return function (a) {\n          return fn.apply(null, a);\n        };\n    }\n  }\n\n  function apply(fn, c, a) {\n    var aLength = a ? a.length : 0;\n    if (c == null) {\n      switch (aLength) {\n        case 0:\n          return fn();\n        case 1:\n          return fn(a[0]);\n        case 2:\n          return fn(a[0], a[1]);\n        case 3:\n          return fn(a[0], a[1], a[2]);\n        case 4:\n          return fn(a[0], a[1], a[2], a[3]);\n        default:\n          return fn.apply(null, a);\n      }\n    } else {\n      switch (aLength) {\n        case 0:\n          return fn.call(c);\n        default:\n          return fn.apply(c, a);\n      }\n    }\n  }\n\n  function fromSubUnsub(sub, unsub, transformer /* Function | falsey */) {\n    return stream(function (emitter) {\n\n      var handler = transformer ? function () {\n        emitter.emit(apply(transformer, this, arguments));\n      } : function (x) {\n        emitter.emit(x);\n      };\n\n      sub(handler);\n      return function () {\n        return unsub(handler);\n      };\n    }).setName('fromSubUnsub');\n  }\n\n  var pairs = [['addEventListener', 'removeEventListener'], ['addListener', 'removeListener'], ['on', 'off']];\n\n  function fromEvents(target, eventName, transformer) {\n    var sub = undefined,\n        unsub = undefined;\n\n    for (var i = 0; i < pairs.length; i++) {\n      if (typeof target[pairs[i][0]] === 'function' && typeof target[pairs[i][1]] === 'function') {\n        sub = pairs[i][0];\n        unsub = pairs[i][1];\n        break;\n      }\n    }\n\n    if (sub === undefined) {\n      throw new Error('target don\\'t support any of ' + 'addEventListener/removeEventListener, addListener/removeListener, on/off method pair');\n    }\n\n    return fromSubUnsub(function (handler) {\n      return target[sub](eventName, handler);\n    }, function (handler) {\n      return target[unsub](eventName, handler);\n    }, transformer).setName('fromEvents');\n  }\n\n  // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n  function P(value) {\n    this._currentEvent = { type: 'value', value: value, current: true };\n  }\n\n  inherit(P, Property, {\n    _name: 'constant',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constant(x) {\n    return new P(x);\n  }\n\n  // HACK:\n  //   We don't call parent Class constructor, but instead putting all necessary\n  //   properties into prototype to simulate ended Property\n  //   (see Propperty and Observable classes).\n\n  function P$1(value) {\n    this._currentEvent = { type: 'error', value: value, current: true };\n  }\n\n  inherit(P$1, Property, {\n    _name: 'constantError',\n    _active: false,\n    _activating: false,\n    _alive: false,\n    _dispatcher: null,\n    _logHandlers: null\n  });\n\n  function constantError(x) {\n    return new P$1(x);\n  }\n\n  function createConstructor(BaseClass, name) {\n    return function AnonymousObservable(source, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._source = source;\n      this._name = source._name + '.' + name;\n      this._init(options);\n      this._$handleAny = function (event) {\n        return _this._handleAny(event);\n      };\n    };\n  }\n\n  function createClassMethods(BaseClass) {\n    return {\n      _init: function () {},\n      _free: function () {},\n      _handleValue: function (x) {\n        this._emitValue(x);\n      },\n      _handleError: function (x) {\n        this._emitError(x);\n      },\n      _handleEnd: function () {\n        this._emitEnd();\n      },\n      _handleAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleValue(event.value);\n          case ERROR:\n            return this._handleError(event.value);\n          case END:\n            return this._handleEnd();\n        }\n      },\n      _onActivation: function () {\n        this._source.onAny(this._$handleAny);\n      },\n      _onDeactivation: function () {\n        this._source.offAny(this._$handleAny);\n      },\n      _clear: function () {\n        BaseClass.prototype._clear.call(this);\n        this._source = null;\n        this._$handleAny = null;\n        this._free();\n      }\n    };\n  }\n\n  function createStream(name, mixin) {\n    var S = createConstructor(Stream, name);\n    inherit(S, Stream, createClassMethods(Stream), mixin);\n    return S;\n  }\n\n  function createProperty(name, mixin) {\n    var P = createConstructor(Property, name);\n    inherit(P, Property, createClassMethods(Property), mixin);\n    return P;\n  }\n\n  var P$2 = createProperty('toProperty', {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._getInitialCurrent = fn;\n    },\n    _onActivation: function () {\n      if (this._getInitialCurrent !== null) {\n        var getInitial = this._getInitialCurrent;\n        this._emitValue(getInitial());\n      }\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n    }\n  });\n\n  function toProperty(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];\n\n    if (fn !== null && typeof fn !== 'function') {\n      throw new Error('You should call toProperty() with a function or no arguments.');\n    }\n    return new P$2(obs, { fn: fn });\n  }\n\n  var S$6 = createStream('changes', {\n    _handleValue: function (x) {\n      if (!this._activating) {\n        this._emitValue(x);\n      }\n    },\n    _handleError: function (x) {\n      if (!this._activating) {\n        this._emitError(x);\n      }\n    }\n  });\n\n  function changes(obs) {\n    return new S$6(obs);\n  }\n\n  function fromPromise(promise) {\n\n    var called = false;\n\n    var result = stream(function (emitter) {\n      if (!called) {\n        var onValue = function (x) {\n          emitter.emit(x);\n          emitter.end();\n        };\n        var onError = function (x) {\n          emitter.error(x);\n          emitter.end();\n        };\n        var _promise = promise.then(onValue, onError);\n\n        // prevent libraries like 'Q' or 'when' from swallowing exceptions\n        if (_promise && typeof _promise.done === 'function') {\n          _promise.done();\n        }\n\n        called = true;\n      }\n    });\n\n    return toProperty(result, null).setName('fromPromise');\n  }\n\n  function getGlodalPromise() {\n    if (typeof Promise === 'function') {\n      return Promise;\n    } else {\n      throw new Error('There isn\\'t default Promise, use shim or parameter');\n    }\n  }\n\n  function toPromise (obs) {\n    var Promise = arguments.length <= 1 || arguments[1] === undefined ? getGlodalPromise() : arguments[1];\n\n    var last = null;\n    return new Promise(function (resolve, reject) {\n      obs.onAny(function (event) {\n        if (event.type === END && last !== null) {\n          (last.type === VALUE ? resolve : reject)(last.value);\n          last = null;\n        } else {\n          last = event;\n        }\n      });\n    });\n  }\n\n  function symbol_ (key) {\n    if (typeof Symbol !== 'undefined' && Symbol[key]) {\n      return Symbol[key];\n    } else if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n      return Symbol.for(key);\n    } else {\n      return '@@' + key;\n    }\n  }\n\n  var symbol = symbol_('observable');\n\n  function fromESObservable(_observable) {\n    var observable = _observable[symbol] ? _observable[symbol]() : _observable;\n    return stream(function (emitter) {\n      var unsub = observable.subscribe({\n        error: function (error) {\n          emitter.error(error);\n          emitter.end();\n        },\n        next: function (value) {\n          emitter.emit(value);\n        },\n        complete: function () {\n          emitter.end();\n        }\n      });\n\n      if (unsub.unsubscribe) {\n        return function () {\n          unsub.unsubscribe();\n        };\n      } else {\n        return unsub;\n      }\n    }).setName('fromESObservable');\n  }\n\n  function ESObservable(observable) {\n    this._observable = observable.takeErrors(1);\n  }\n\n  extend(ESObservable.prototype, {\n    subscribe: function (observer) {\n      var _this = this;\n\n      var fn = function (event) {\n        if (event.type === VALUE && observer.next) {\n          observer.next(event.value);\n        } else if (event.type === ERROR && observer.error) {\n          observer.error(event.value);\n        } else if (event.type === END && observer.complete) {\n          observer.complete(event.value);\n        }\n      };\n\n      this._observable.onAny(fn);\n      return function () {\n        return _this._observable.offAny(fn);\n      };\n    }\n  });\n\n  function toESObservable() {\n    return new ESObservable(this);\n  }\n\n  var mixin = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      this._emitValue(fn(x));\n    }\n  };\n\n  var S$7 = createStream('map', mixin);\n  var P$3 = createProperty('map', mixin);\n\n  var id = function (x) {\n    return x;\n  };\n\n  function map$1(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id : arguments[1];\n\n    return new (obs._ofSameType(S$7, P$3))(obs, { fn: fn });\n  }\n\n  var mixin$1 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$8 = createStream('filter', mixin$1);\n  var P$4 = createProperty('filter', mixin$1);\n\n  var id$1 = function (x) {\n    return x;\n  };\n\n  function filter(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$1 : arguments[1];\n\n    return new (obs._ofSameType(S$8, P$4))(obs, { fn: fn });\n  }\n\n  var mixin$2 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = n;\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleValue: function (x) {\n      this._n--;\n      this._emitValue(x);\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$9 = createStream('take', mixin$2);\n  var P$5 = createProperty('take', mixin$2);\n\n  function take(obs, n) {\n    return new (obs._ofSameType(S$9, P$5))(obs, { n: n });\n  }\n\n  var mixin$3 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = n;\n      if (n <= 0) {\n        this._emitEnd();\n      }\n    },\n    _handleError: function (x) {\n      this._n--;\n      this._emitError(x);\n      if (this._n === 0) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$10 = createStream('takeErrors', mixin$3);\n  var P$6 = createProperty('takeErrors', mixin$3);\n\n  function takeErrors(obs, n) {\n    return new (obs._ofSameType(S$10, P$6))(obs, { n: n });\n  }\n\n  var mixin$4 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitValue(x);\n      } else {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$11 = createStream('takeWhile', mixin$4);\n  var P$7 = createProperty('takeWhile', mixin$4);\n\n  var id$2 = function (x) {\n    return x;\n  };\n\n  function takeWhile(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$2 : arguments[1];\n\n    return new (obs._ofSameType(S$11, P$7))(obs, { fn: fn });\n  }\n\n  var mixin$5 = {\n    _init: function () {\n      this._lastValue = NOTHING;\n    },\n    _free: function () {\n      this._lastValue = null;\n    },\n    _handleValue: function (x) {\n      this._lastValue = x;\n    },\n    _handleEnd: function () {\n      if (this._lastValue !== NOTHING) {\n        this._emitValue(this._lastValue);\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$12 = createStream('last', mixin$5);\n  var P$8 = createProperty('last', mixin$5);\n\n  function last(obs) {\n    return new (obs._ofSameType(S$12, P$8))(obs);\n  }\n\n  var mixin$6 = {\n    _init: function (_ref) {\n      var n = _ref.n;\n\n      this._n = Math.max(0, n);\n    },\n    _handleValue: function (x) {\n      if (this._n === 0) {\n        this._emitValue(x);\n      } else {\n        this._n--;\n      }\n    }\n  };\n\n  var S$13 = createStream('skip', mixin$6);\n  var P$9 = createProperty('skip', mixin$6);\n\n  function skip(obs, n) {\n    return new (obs._ofSameType(S$13, P$9))(obs, { n: n });\n  }\n\n  var mixin$7 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._fn !== null && !fn(x)) {\n        this._fn = null;\n      }\n      if (this._fn === null) {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$14 = createStream('skipWhile', mixin$7);\n  var P$10 = createProperty('skipWhile', mixin$7);\n\n  var id$3 = function (x) {\n    return x;\n  };\n\n  function skipWhile(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$3 : arguments[1];\n\n    return new (obs._ofSameType(S$14, P$10))(obs, { fn: fn });\n  }\n\n  var mixin$8 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n      this._prev = NOTHING;\n    },\n    _free: function () {\n      this._fn = null;\n      this._prev = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._prev === NOTHING || !fn(this._prev, x)) {\n        this._prev = x;\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$15 = createStream('skipDuplicates', mixin$8);\n  var P$11 = createProperty('skipDuplicates', mixin$8);\n\n  var eq = function (a, b) {\n    return a === b;\n  };\n\n  function skipDuplicates(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? eq : arguments[1];\n\n    return new (obs._ofSameType(S$15, P$11))(obs, { fn: fn });\n  }\n\n  var mixin$9 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var seed = _ref.seed;\n\n      this._fn = fn;\n      this._prev = seed;\n    },\n    _free: function () {\n      this._prev = null;\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      if (this._prev !== NOTHING) {\n        var fn = this._fn;\n        this._emitValue(fn(this._prev, x));\n      }\n      this._prev = x;\n    }\n  };\n\n  var S$16 = createStream('diff', mixin$9);\n  var P$12 = createProperty('diff', mixin$9);\n\n  function defaultFn(a, b) {\n    return [a, b];\n  }\n\n  function diff(obs, fn) {\n    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\n    return new (obs._ofSameType(S$16, P$12))(obs, { fn: fn || defaultFn, seed: seed });\n  }\n\n  var P$13 = createProperty('scan', {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var seed = _ref.seed;\n\n      this._fn = fn;\n      this._seed = seed;\n      if (seed !== NOTHING) {\n        this._emitValue(seed);\n      }\n    },\n    _free: function () {\n      this._fn = null;\n      this._seed = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      if (this._currentEvent === null || this._currentEvent.type === ERROR) {\n        this._emitValue(this._seed === NOTHING ? x : fn(this._seed, x));\n      } else {\n        this._emitValue(fn(this._currentEvent.value, x));\n      }\n    }\n  });\n\n  function scan(obs, fn) {\n    var seed = arguments.length <= 2 || arguments[2] === undefined ? NOTHING : arguments[2];\n\n    return new P$13(obs, { fn: fn, seed: seed });\n  }\n\n  var mixin$10 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      var xs = fn(x);\n      for (var i = 0; i < xs.length; i++) {\n        this._emitValue(xs[i]);\n      }\n    }\n  };\n\n  var S$17 = createStream('flatten', mixin$10);\n\n  var id$4 = function (x) {\n    return x;\n  };\n\n  function flatten(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$4 : arguments[1];\n\n    return new S$17(obs, { fn: fn });\n  }\n\n  var END_MARKER = {};\n\n  var mixin$11 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n\n      this._wait = Math.max(0, wait);\n      this._buff = [];\n      this._$shiftBuff = function () {\n        var value = _this._buff.shift();\n        if (value === END_MARKER) {\n          _this._emitEnd();\n        } else {\n          _this._emitValue(value);\n        }\n      };\n    },\n    _free: function () {\n      this._buff = null;\n      this._$shiftBuff = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._buff.push(x);\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        this._buff.push(END_MARKER);\n        setTimeout(this._$shiftBuff, this._wait);\n      }\n    }\n  };\n\n  var S$18 = createStream('delay', mixin$11);\n  var P$14 = createProperty('delay', mixin$11);\n\n  function delay(obs, wait) {\n    return new (obs._ofSameType(S$18, P$14))(obs, { wait: wait });\n  }\n\n  var now = Date.now ? function () {\n    return Date.now();\n  } : function () {\n    return new Date().getTime();\n  };\n\n  var mixin$12 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var leading = _ref.leading;\n      var trailing = _ref.trailing;\n\n      this._wait = Math.max(0, wait);\n      this._leading = leading;\n      this._trailing = trailing;\n      this._trailingValue = null;\n      this._timeoutId = null;\n      this._endLater = false;\n      this._lastCallTime = 0;\n      this._$trailingCall = function () {\n        return _this._trailingCall();\n      };\n    },\n    _free: function () {\n      this._trailingValue = null;\n      this._$trailingCall = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        var curTime = now();\n        if (this._lastCallTime === 0 && !this._leading) {\n          this._lastCallTime = curTime;\n        }\n        var remaining = this._wait - (curTime - this._lastCallTime);\n        if (remaining <= 0) {\n          this._cancelTrailing();\n          this._lastCallTime = curTime;\n          this._emitValue(x);\n        } else if (this._trailing) {\n          this._cancelTrailing();\n          this._trailingValue = x;\n          this._timeoutId = setTimeout(this._$trailingCall, remaining);\n        }\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _cancelTrailing: function () {\n      if (this._timeoutId !== null) {\n        clearTimeout(this._timeoutId);\n        this._timeoutId = null;\n      }\n    },\n    _trailingCall: function () {\n      this._emitValue(this._trailingValue);\n      this._timeoutId = null;\n      this._trailingValue = null;\n      this._lastCallTime = !this._leading ? 0 : now();\n      if (this._endLater) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$19 = createStream('throttle', mixin$12);\n  var P$15 = createProperty('throttle', mixin$12);\n\n  function throttle(obs, wait) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$leading = _ref2.leading;\n    var leading = _ref2$leading === undefined ? true : _ref2$leading;\n    var _ref2$trailing = _ref2.trailing;\n    var trailing = _ref2$trailing === undefined ? true : _ref2$trailing;\n\n    return new (obs._ofSameType(S$19, P$15))(obs, { wait: wait, leading: leading, trailing: trailing });\n  }\n\n  var mixin$13 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var immediate = _ref.immediate;\n\n      this._wait = Math.max(0, wait);\n      this._immediate = immediate;\n      this._lastAttempt = 0;\n      this._timeoutId = null;\n      this._laterValue = null;\n      this._endLater = false;\n      this._$later = function () {\n        return _this._later();\n      };\n    },\n    _free: function () {\n      this._laterValue = null;\n      this._$later = null;\n    },\n    _handleValue: function (x) {\n      if (this._activating) {\n        this._emitValue(x);\n      } else {\n        this._lastAttempt = now();\n        if (this._immediate && !this._timeoutId) {\n          this._emitValue(x);\n        }\n        if (!this._timeoutId) {\n          this._timeoutId = setTimeout(this._$later, this._wait);\n        }\n        if (!this._immediate) {\n          this._laterValue = x;\n        }\n      }\n    },\n    _handleEnd: function () {\n      if (this._activating) {\n        this._emitEnd();\n      } else {\n        if (this._timeoutId && !this._immediate) {\n          this._endLater = true;\n        } else {\n          this._emitEnd();\n        }\n      }\n    },\n    _later: function () {\n      var last = now() - this._lastAttempt;\n      if (last < this._wait && last >= 0) {\n        this._timeoutId = setTimeout(this._$later, this._wait - last);\n      } else {\n        this._timeoutId = null;\n        if (!this._immediate) {\n          this._emitValue(this._laterValue);\n          this._laterValue = null;\n        }\n        if (this._endLater) {\n          this._emitEnd();\n        }\n      }\n    }\n  };\n\n  var S$20 = createStream('debounce', mixin$13);\n  var P$16 = createProperty('debounce', mixin$13);\n\n  function debounce(obs, wait) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$immediate = _ref2.immediate;\n    var immediate = _ref2$immediate === undefined ? false : _ref2$immediate;\n\n    return new (obs._ofSameType(S$20, P$16))(obs, { wait: wait, immediate: immediate });\n  }\n\n  var mixin$14 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      this._emitError(fn(x));\n    }\n  };\n\n  var S$21 = createStream('mapErrors', mixin$14);\n  var P$17 = createProperty('mapErrors', mixin$14);\n\n  var id$5 = function (x) {\n    return x;\n  };\n\n  function mapErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$5 : arguments[1];\n\n    return new (obs._ofSameType(S$21, P$17))(obs, { fn: fn });\n  }\n\n  var mixin$15 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      if (fn(x)) {\n        this._emitError(x);\n      }\n    }\n  };\n\n  var S$22 = createStream('filterErrors', mixin$15);\n  var P$18 = createProperty('filterErrors', mixin$15);\n\n  var id$6 = function (x) {\n    return x;\n  };\n\n  function filterErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? id$6 : arguments[1];\n\n    return new (obs._ofSameType(S$22, P$18))(obs, { fn: fn });\n  }\n\n  var mixin$16 = {\n    _handleValue: function () {}\n  };\n\n  var S$23 = createStream('ignoreValues', mixin$16);\n  var P$19 = createProperty('ignoreValues', mixin$16);\n\n  function ignoreValues(obs) {\n    return new (obs._ofSameType(S$23, P$19))(obs);\n  }\n\n  var mixin$17 = {\n    _handleError: function () {}\n  };\n\n  var S$24 = createStream('ignoreErrors', mixin$17);\n  var P$20 = createProperty('ignoreErrors', mixin$17);\n\n  function ignoreErrors(obs) {\n    return new (obs._ofSameType(S$24, P$20))(obs);\n  }\n\n  var mixin$18 = {\n    _handleEnd: function () {}\n  };\n\n  var S$25 = createStream('ignoreEnd', mixin$18);\n  var P$21 = createProperty('ignoreEnd', mixin$18);\n\n  function ignoreEnd(obs) {\n    return new (obs._ofSameType(S$25, P$21))(obs);\n  }\n\n  var mixin$19 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleEnd: function () {\n      var fn = this._fn;\n      this._emitValue(fn());\n      this._emitEnd();\n    }\n  };\n\n  var S$26 = createStream('beforeEnd', mixin$19);\n  var P$22 = createProperty('beforeEnd', mixin$19);\n\n  function beforeEnd(obs, fn) {\n    return new (obs._ofSameType(S$26, P$22))(obs, { fn: fn });\n  }\n\n  var mixin$20 = {\n    _init: function (_ref) {\n      var min = _ref.min;\n      var max = _ref.max;\n\n      this._max = max;\n      this._min = min;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _handleValue: function (x) {\n      this._buff = slide(this._buff, x, this._max);\n      if (this._buff.length >= this._min) {\n        this._emitValue(this._buff);\n      }\n    }\n  };\n\n  var S$27 = createStream('slidingWindow', mixin$20);\n  var P$23 = createProperty('slidingWindow', mixin$20);\n\n  function slidingWindow(obs, max) {\n    var min = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];\n\n    return new (obs._ofSameType(S$27, P$23))(obs, { min: min, max: max });\n  }\n\n  var mixin$21 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._fn = fn;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      var fn = this._fn;\n      if (!fn(x)) {\n        this._flush();\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$28 = createStream('bufferWhile', mixin$21);\n  var P$24 = createProperty('bufferWhile', mixin$21);\n\n  var id$7 = function (x) {\n    return x;\n  };\n\n  function bufferWhile(obs, fn) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$28, P$24))(obs, { fn: fn || id$7, flushOnEnd: flushOnEnd });\n  }\n\n  var mixin$22 = {\n    _init: function (_ref) {\n      var count = _ref.count;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._buff = [];\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null && this._buff.length !== 0) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      if (this._buff.length >= this._count) {\n        this._flush();\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    }\n  };\n\n  var S$29 = createStream('bufferWithCount', mixin$22);\n  var P$25 = createProperty('bufferWithCount', mixin$22);\n\n  function bufferWhile$1(obs, count) {\n    var _ref2 = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$29, P$25))(obs, { count: count, flushOnEnd: flushOnEnd });\n  }\n\n  var mixin$23 = {\n    _init: function (_ref) {\n      var _this = this;\n\n      var wait = _ref.wait;\n      var count = _ref.count;\n      var flushOnEnd = _ref.flushOnEnd;\n\n      this._wait = wait;\n      this._count = count;\n      this._flushOnEnd = flushOnEnd;\n      this._intervalId = null;\n      this._$onTick = function () {\n        return _this._flush();\n      };\n      this._buff = [];\n    },\n    _free: function () {\n      this._$onTick = null;\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handleValue: function (x) {\n      this._buff.push(x);\n      if (this._buff.length >= this._count) {\n        clearInterval(this._intervalId);\n        this._flush();\n        this._intervalId = setInterval(this._$onTick, this._wait);\n      }\n    },\n    _handleEnd: function () {\n      if (this._flushOnEnd && this._buff.length !== 0) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _onActivation: function () {\n      this._source.onAny(this._$handleAny); // copied from patterns/one-source\n      this._intervalId = setInterval(this._$onTick, this._wait);\n    },\n    _onDeactivation: function () {\n      if (this._intervalId !== null) {\n        clearInterval(this._intervalId);\n        this._intervalId = null;\n      }\n      this._source.offAny(this._$handleAny); // copied from patterns/one-source\n    }\n  };\n\n  var S$30 = createStream('bufferWithTimeOrCount', mixin$23);\n  var P$26 = createProperty('bufferWithTimeOrCount', mixin$23);\n\n  function bufferWithTimeOrCount(obs, wait, count) {\n    var _ref2 = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n    var _ref2$flushOnEnd = _ref2.flushOnEnd;\n    var flushOnEnd = _ref2$flushOnEnd === undefined ? true : _ref2$flushOnEnd;\n\n    return new (obs._ofSameType(S$30, P$26))(obs, { wait: wait, count: count, flushOnEnd: flushOnEnd });\n  }\n\n  function xformForObs(obs) {\n    return {\n      '@@transducer/step': function (res, input) {\n        obs._emitValue(input);\n        return null;\n      },\n      '@@transducer/result': function () {\n        obs._emitEnd();\n        return null;\n      }\n    };\n  }\n\n  var mixin$24 = {\n    _init: function (_ref) {\n      var transducer = _ref.transducer;\n\n      this._xform = transducer(xformForObs(this));\n    },\n    _free: function () {\n      this._xform = null;\n    },\n    _handleValue: function (x) {\n      if (this._xform['@@transducer/step'](null, x) !== null) {\n        this._xform['@@transducer/result'](null);\n      }\n    },\n    _handleEnd: function () {\n      this._xform['@@transducer/result'](null);\n    }\n  };\n\n  var S$31 = createStream('transduce', mixin$24);\n  var P$27 = createProperty('transduce', mixin$24);\n\n  function transduce(obs, transducer) {\n    return new (obs._ofSameType(S$31, P$27))(obs, { transducer: transducer });\n  }\n\n  var mixin$25 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._handler = fn;\n      this._emitter = emitter(this);\n    },\n    _free: function () {\n      this._handler = null;\n      this._emitter = null;\n    },\n    _handleAny: function (event) {\n      this._handler(this._emitter, event);\n    }\n  };\n\n  var S$32 = createStream('withHandler', mixin$25);\n  var P$28 = createProperty('withHandler', mixin$25);\n\n  function withHandler(obs, fn) {\n    return new (obs._ofSameType(S$32, P$28))(obs, { fn: fn });\n  }\n\n  function defaultErrorsCombinator(errors) {\n    var latestError = undefined;\n    for (var i = 0; i < errors.length; i++) {\n      if (errors[i] !== undefined) {\n        if (latestError === undefined || latestError.index < errors[i].index) {\n          latestError = errors[i];\n        }\n      }\n    }\n    return latestError.error;\n  }\n\n  function Combine(active, passive, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._activeCount = active.length;\n    this._sources = concat(active, passive);\n    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n      return x;\n    };\n    this._aliveCount = 0;\n    this._latestValues = new Array(this._sources.length);\n    this._latestErrors = new Array(this._sources.length);\n    fillArray(this._latestValues, NOTHING);\n    this._emitAfterActivation = false;\n    this._endAfterActivation = false;\n    this._latestErrorIndex = 0;\n\n    this._$handlers = [];\n\n    var _loop = function (i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Combine, Stream, {\n\n    _name: 'combine',\n\n    _onActivation: function () {\n      this._aliveCount = this._activeCount;\n\n      // we need to suscribe to _passive_ sources before _active_\n      // (see https://github.com/rpominov/kefir/issues/98)\n      for (var i = this._activeCount; i < this._sources.length; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n      for (var i = 0; i < this._activeCount; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n\n      if (this._emitAfterActivation) {\n        this._emitAfterActivation = false;\n        this._emitIfFull();\n      }\n      if (this._endAfterActivation) {\n        this._emitEnd();\n      }\n    },\n    _onDeactivation: function () {\n      var length = this._sources.length,\n          i = undefined;\n      for (i = 0; i < length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emitIfFull: function () {\n      var hasAllValues = true;\n      var hasErrors = false;\n      var length = this._latestValues.length;\n      var valuesCopy = new Array(length);\n      var errorsCopy = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        valuesCopy[i] = this._latestValues[i];\n        errorsCopy[i] = this._latestErrors[i];\n\n        if (valuesCopy[i] === NOTHING) {\n          hasAllValues = false;\n        }\n\n        if (errorsCopy[i] !== undefined) {\n          hasErrors = true;\n        }\n      }\n\n      if (hasAllValues) {\n        var combinator = this._combinator;\n        this._emitValue(combinator(valuesCopy));\n      }\n      if (hasErrors) {\n        this._emitError(defaultErrorsCombinator(errorsCopy));\n      }\n    },\n    _handleAny: function (i, event) {\n\n      if (event.type === VALUE || event.type === ERROR) {\n\n        if (event.type === VALUE) {\n          this._latestValues[i] = event.value;\n          this._latestErrors[i] = undefined;\n        }\n        if (event.type === ERROR) {\n          this._latestValues[i] = NOTHING;\n          this._latestErrors[i] = {\n            index: this._latestErrorIndex++,\n            error: event.value\n          };\n        }\n\n        if (i < this._activeCount) {\n          if (this._activating) {\n            this._emitAfterActivation = true;\n          } else {\n            this._emitIfFull();\n          }\n        }\n      } else {\n        // END\n\n        if (i < this._activeCount) {\n          this._aliveCount--;\n          if (this._aliveCount === 0) {\n            if (this._activating) {\n              this._endAfterActivation = true;\n            } else {\n              this._emitEnd();\n            }\n          }\n        }\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._sources = null;\n      this._latestValues = null;\n      this._latestErrors = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function combine(active) {\n    var passive = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];\n    var combinator = arguments[2];\n\n    if (typeof passive === 'function') {\n      combinator = passive;\n      passive = [];\n    }\n    return active.length === 0 ? never() : new Combine(active, passive, combinator);\n  }\n\n  var isArray = Array.isArray || function (xs) {\n    return Object.prototype.toString.call(xs) === '[object Array]';\n  };\n\n  function Zip(sources, combinator) {\n    var _this = this;\n\n    Stream.call(this);\n\n    this._buffers = map(sources, function (source) {\n      return isArray(source) ? cloneArray(source) : [];\n    });\n    this._sources = map(sources, function (source) {\n      return isArray(source) ? never() : source;\n    });\n\n    this._combinator = combinator ? spread(combinator, this._sources.length) : function (x) {\n      return x;\n    };\n    this._aliveCount = 0;\n\n    this._$handlers = [];\n\n    var _loop = function (i) {\n      _this._$handlers.push(function (event) {\n        return _this._handleAny(i, event);\n      });\n    };\n\n    for (var i = 0; i < this._sources.length; i++) {\n      _loop(i);\n    }\n  }\n\n  inherit(Zip, Stream, {\n\n    _name: 'zip',\n\n    _onActivation: function () {\n\n      // if all sources are arrays\n      while (this._isFull()) {\n        this._emit();\n      }\n\n      var length = this._sources.length;\n      this._aliveCount = length;\n      for (var i = 0; i < length && this._active; i++) {\n        this._sources[i].onAny(this._$handlers[i]);\n      }\n    },\n    _onDeactivation: function () {\n      for (var i = 0; i < this._sources.length; i++) {\n        this._sources[i].offAny(this._$handlers[i]);\n      }\n    },\n    _emit: function () {\n      var values = new Array(this._buffers.length);\n      for (var i = 0; i < this._buffers.length; i++) {\n        values[i] = this._buffers[i].shift();\n      }\n      var combinator = this._combinator;\n      this._emitValue(combinator(values));\n    },\n    _isFull: function () {\n      for (var i = 0; i < this._buffers.length; i++) {\n        if (this._buffers[i].length === 0) {\n          return false;\n        }\n      }\n      return true;\n    },\n    _handleAny: function (i, event) {\n      if (event.type === VALUE) {\n        this._buffers[i].push(event.value);\n        if (this._isFull()) {\n          this._emit();\n        }\n      }\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n      if (event.type === END) {\n        this._aliveCount--;\n        if (this._aliveCount === 0) {\n          this._emitEnd();\n        }\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._sources = null;\n      this._buffers = null;\n      this._combinator = null;\n      this._$handlers = null;\n    }\n  });\n\n  function zip(observables, combinator /* Function | falsey */) {\n    return observables.length === 0 ? never() : new Zip(observables, combinator);\n  }\n\n  var id$8 = function (x) {\n    return x;\n  };\n\n  function AbstractPool() {\n    var _this = this;\n\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n    var _ref$queueLim = _ref.queueLim;\n    var queueLim = _ref$queueLim === undefined ? 0 : _ref$queueLim;\n    var _ref$concurLim = _ref.concurLim;\n    var concurLim = _ref$concurLim === undefined ? -1 : _ref$concurLim;\n    var _ref$drop = _ref.drop;\n    var drop = _ref$drop === undefined ? 'new' : _ref$drop;\n\n    Stream.call(this);\n\n    this._queueLim = queueLim < 0 ? -1 : queueLim;\n    this._concurLim = concurLim < 0 ? -1 : concurLim;\n    this._drop = drop;\n    this._queue = [];\n    this._curSources = [];\n    this._$handleSubAny = function (event) {\n      return _this._handleSubAny(event);\n    };\n    this._$endHandlers = [];\n    this._currentlyAdding = null;\n\n    if (this._concurLim === 0) {\n      this._emitEnd();\n    }\n  }\n\n  inherit(AbstractPool, Stream, {\n\n    _name: 'abstractPool',\n\n    _add: function (obj, toObs /* Function | falsey */) {\n      toObs = toObs || id$8;\n      if (this._concurLim === -1 || this._curSources.length < this._concurLim) {\n        this._addToCur(toObs(obj));\n      } else {\n        if (this._queueLim === -1 || this._queue.length < this._queueLim) {\n          this._addToQueue(toObs(obj));\n        } else if (this._drop === 'old') {\n          this._removeOldest();\n          this._add(obj, toObs);\n        }\n      }\n    },\n    _addAll: function (obss) {\n      var _this2 = this;\n\n      forEach(obss, function (obs) {\n        return _this2._add(obs);\n      });\n    },\n    _remove: function (obs) {\n      if (this._removeCur(obs) === -1) {\n        this._removeQueue(obs);\n      }\n    },\n    _addToQueue: function (obs) {\n      this._queue = concat(this._queue, [obs]);\n    },\n    _addToCur: function (obs) {\n      if (this._active) {\n\n        // HACK:\n        //\n        // We have two optimizations for cases when `obs` is ended. We don't want\n        // to add such observable to the list, but only want to emit events\n        // from it (if it has some).\n        //\n        // Instead of this hacks, we could just did following,\n        // but it would be 5-8 times slower:\n        //\n        //     this._curSources = concat(this._curSources, [obs]);\n        //     this._subscribe(obs);\n        //\n\n        // #1\n        // This one for cases when `obs` already ended\n        // e.g., Kefir.constant() or Kefir.never()\n        if (!obs._alive) {\n          if (obs._currentEvent) {\n            this._emit(obs._currentEvent.type, obs._currentEvent.value);\n          }\n          return;\n        }\n\n        // #2\n        // This one is for cases when `obs` going to end synchronously on\n        // first subscriber e.g., Kefir.stream(em => {em.emit(1); em.end()})\n        this._currentlyAdding = obs;\n        obs.onAny(this._$handleSubAny);\n        this._currentlyAdding = null;\n        if (obs._alive) {\n          this._curSources = concat(this._curSources, [obs]);\n          if (this._active) {\n            this._subToEnd(obs);\n          }\n        }\n      } else {\n        this._curSources = concat(this._curSources, [obs]);\n      }\n    },\n    _subToEnd: function (obs) {\n      var _this3 = this;\n\n      var onEnd = function () {\n        return _this3._removeCur(obs);\n      };\n      this._$endHandlers.push({ obs: obs, handler: onEnd });\n      obs.onEnd(onEnd);\n    },\n    _subscribe: function (obs) {\n      obs.onAny(this._$handleSubAny);\n\n      // it can become inactive in responce of subscribing to `obs.onAny` above\n      if (this._active) {\n        this._subToEnd(obs);\n      }\n    },\n    _unsubscribe: function (obs) {\n      obs.offAny(this._$handleSubAny);\n\n      var onEndI = findByPred(this._$endHandlers, function (obj) {\n        return obj.obs === obs;\n      });\n      if (onEndI !== -1) {\n        obs.offEnd(this._$endHandlers[onEndI].handler);\n        this._$endHandlers.splice(onEndI, 1);\n      }\n    },\n    _handleSubAny: function (event) {\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      } else if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n    },\n    _removeQueue: function (obs) {\n      var index = find(this._queue, obs);\n      this._queue = remove(this._queue, index);\n      return index;\n    },\n    _removeCur: function (obs) {\n      if (this._active) {\n        this._unsubscribe(obs);\n      }\n      var index = find(this._curSources, obs);\n      this._curSources = remove(this._curSources, index);\n      if (index !== -1) {\n        if (this._queue.length !== 0) {\n          this._pullQueue();\n        } else if (this._curSources.length === 0) {\n          this._onEmpty();\n        }\n      }\n      return index;\n    },\n    _removeOldest: function () {\n      this._removeCur(this._curSources[0]);\n    },\n    _pullQueue: function () {\n      if (this._queue.length !== 0) {\n        this._queue = cloneArray(this._queue);\n        this._addToCur(this._queue.shift());\n      }\n    },\n    _onActivation: function () {\n      for (var i = 0, sources = this._curSources; i < sources.length && this._active; i++) {\n        this._subscribe(sources[i]);\n      }\n    },\n    _onDeactivation: function () {\n      for (var i = 0, sources = this._curSources; i < sources.length; i++) {\n        this._unsubscribe(sources[i]);\n      }\n      if (this._currentlyAdding !== null) {\n        this._unsubscribe(this._currentlyAdding);\n      }\n    },\n    _isEmpty: function () {\n      return this._curSources.length === 0;\n    },\n    _onEmpty: function () {},\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._queue = null;\n      this._curSources = null;\n      this._$handleSubAny = null;\n      this._$endHandlers = null;\n    }\n  });\n\n  function Merge(sources) {\n    AbstractPool.call(this);\n    this._addAll(sources);\n    this._initialised = true;\n  }\n\n  inherit(Merge, AbstractPool, {\n\n    _name: 'merge',\n\n    _onEmpty: function () {\n      if (this._initialised) {\n        this._emitEnd();\n      }\n    }\n  });\n\n  function merge(observables) {\n    return observables.length === 0 ? never() : new Merge(observables);\n  }\n\n  function S$33(generator) {\n    var _this = this;\n\n    Stream.call(this);\n    this._generator = generator;\n    this._source = null;\n    this._inLoop = false;\n    this._iteration = 0;\n    this._$handleAny = function (event) {\n      return _this._handleAny(event);\n    };\n  }\n\n  inherit(S$33, Stream, {\n\n    _name: 'repeat',\n\n    _handleAny: function (event) {\n      if (event.type === END) {\n        this._source = null;\n        this._getSource();\n      } else {\n        this._emit(event.type, event.value);\n      }\n    },\n    _getSource: function () {\n      if (!this._inLoop) {\n        this._inLoop = true;\n        var generator = this._generator;\n        while (this._source === null && this._alive && this._active) {\n          this._source = generator(this._iteration++);\n          if (this._source) {\n            this._source.onAny(this._$handleAny);\n          } else {\n            this._emitEnd();\n          }\n        }\n        this._inLoop = false;\n      }\n    },\n    _onActivation: function () {\n      if (this._source) {\n        this._source.onAny(this._$handleAny);\n      } else {\n        this._getSource();\n      }\n    },\n    _onDeactivation: function () {\n      if (this._source) {\n        this._source.offAny(this._$handleAny);\n      }\n    },\n    _clear: function () {\n      Stream.prototype._clear.call(this);\n      this._generator = null;\n      this._source = null;\n      this._$handleAny = null;\n    }\n  });\n\n  function repeat (generator) {\n    return new S$33(generator);\n  }\n\n  function concat$1(observables) {\n    return repeat(function (index) {\n      return observables.length > index ? observables[index] : false;\n    }).setName('concat');\n  }\n\n  function Pool() {\n    AbstractPool.call(this);\n  }\n\n  inherit(Pool, AbstractPool, {\n\n    _name: 'pool',\n\n    plug: function (obs) {\n      this._add(obs);\n      return this;\n    },\n    unplug: function (obs) {\n      this._remove(obs);\n      return this;\n    }\n  });\n\n  function FlatMap(source, fn, options) {\n    var _this = this;\n\n    AbstractPool.call(this, options);\n    this._source = source;\n    this._fn = fn;\n    this._mainEnded = false;\n    this._lastCurrent = null;\n    this._$handleMain = function (event) {\n      return _this._handleMain(event);\n    };\n  }\n\n  inherit(FlatMap, AbstractPool, {\n    _onActivation: function () {\n      AbstractPool.prototype._onActivation.call(this);\n      if (this._active) {\n        this._source.onAny(this._$handleMain);\n      }\n    },\n    _onDeactivation: function () {\n      AbstractPool.prototype._onDeactivation.call(this);\n      this._source.offAny(this._$handleMain);\n      this._hadNoEvSinceDeact = true;\n    },\n    _handleMain: function (event) {\n\n      if (event.type === VALUE) {\n        // Is latest value before deactivation survived, and now is 'current' on this activation?\n        // We don't want to handle such values, to prevent to constantly add\n        // same observale on each activation/deactivation when our main source\n        // is a `Kefir.conatant()` for example.\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === ERROR) {\n        this._emitError(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    },\n    _onEmpty: function () {\n      if (this._mainEnded) {\n        this._emitEnd();\n      }\n    },\n    _clear: function () {\n      AbstractPool.prototype._clear.call(this);\n      this._source = null;\n      this._lastCurrent = null;\n      this._$handleMain = null;\n    }\n  });\n\n  function FlatMapErrors(source, fn) {\n    FlatMap.call(this, source, fn);\n  }\n\n  inherit(FlatMapErrors, FlatMap, {\n\n    // Same as in FlatMap, only VALUE/ERROR flipped\n\n    _handleMain: function (event) {\n\n      if (event.type === ERROR) {\n        var sameCurr = this._activating && this._hadNoEvSinceDeact && this._lastCurrent === event.value;\n        if (!sameCurr) {\n          this._add(event.value, this._fn);\n        }\n        this._lastCurrent = event.value;\n        this._hadNoEvSinceDeact = false;\n      }\n\n      if (event.type === VALUE) {\n        this._emitValue(event.value);\n      }\n\n      if (event.type === END) {\n        if (this._isEmpty()) {\n          this._emitEnd();\n        } else {\n          this._mainEnded = true;\n        }\n      }\n    }\n  });\n\n  function createConstructor$1(BaseClass, name) {\n    return function AnonymousObservable(primary, secondary, options) {\n      var _this = this;\n\n      BaseClass.call(this);\n      this._primary = primary;\n      this._secondary = secondary;\n      this._name = primary._name + '.' + name;\n      this._lastSecondary = NOTHING;\n      this._$handleSecondaryAny = function (event) {\n        return _this._handleSecondaryAny(event);\n      };\n      this._$handlePrimaryAny = function (event) {\n        return _this._handlePrimaryAny(event);\n      };\n      this._init(options);\n    };\n  }\n\n  function createClassMethods$1(BaseClass) {\n    return {\n      _init: function () {},\n      _free: function () {},\n      _handlePrimaryValue: function (x) {\n        this._emitValue(x);\n      },\n      _handlePrimaryError: function (x) {\n        this._emitError(x);\n      },\n      _handlePrimaryEnd: function () {\n        this._emitEnd();\n      },\n      _handleSecondaryValue: function (x) {\n        this._lastSecondary = x;\n      },\n      _handleSecondaryError: function (x) {\n        this._emitError(x);\n      },\n      _handleSecondaryEnd: function () {},\n      _handlePrimaryAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handlePrimaryValue(event.value);\n          case ERROR:\n            return this._handlePrimaryError(event.value);\n          case END:\n            return this._handlePrimaryEnd(event.value);\n        }\n      },\n      _handleSecondaryAny: function (event) {\n        switch (event.type) {\n          case VALUE:\n            return this._handleSecondaryValue(event.value);\n          case ERROR:\n            return this._handleSecondaryError(event.value);\n          case END:\n            this._handleSecondaryEnd(event.value);\n            this._removeSecondary();\n        }\n      },\n      _removeSecondary: function () {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n          this._$handleSecondaryAny = null;\n          this._secondary = null;\n        }\n      },\n      _onActivation: function () {\n        if (this._secondary !== null) {\n          this._secondary.onAny(this._$handleSecondaryAny);\n        }\n        if (this._active) {\n          this._primary.onAny(this._$handlePrimaryAny);\n        }\n      },\n      _onDeactivation: function () {\n        if (this._secondary !== null) {\n          this._secondary.offAny(this._$handleSecondaryAny);\n        }\n        this._primary.offAny(this._$handlePrimaryAny);\n      },\n      _clear: function () {\n        BaseClass.prototype._clear.call(this);\n        this._primary = null;\n        this._secondary = null;\n        this._lastSecondary = null;\n        this._$handleSecondaryAny = null;\n        this._$handlePrimaryAny = null;\n        this._free();\n      }\n    };\n  }\n\n  function createStream$1(name, mixin) {\n    var S = createConstructor$1(Stream, name);\n    inherit(S, Stream, createClassMethods$1(Stream), mixin);\n    return S;\n  }\n\n  function createProperty$1(name, mixin) {\n    var P = createConstructor$1(Property, name);\n    inherit(P, Property, createClassMethods$1(Property), mixin);\n    return P;\n  }\n\n  var mixin$26 = {\n    _handlePrimaryValue: function (x) {\n      if (this._lastSecondary !== NOTHING && this._lastSecondary) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (this._lastSecondary === NOTHING || !this._lastSecondary) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$34 = createStream$1('filterBy', mixin$26);\n  var P$29 = createProperty$1('filterBy', mixin$26);\n\n  function filterBy(primary, secondary) {\n    return new (primary._ofSameType(S$34, P$29))(primary, secondary);\n  }\n\n  var id2 = function (_, x) {\n    return x;\n  };\n\n  function sampledBy(passive, active, combinator) {\n    var _combinator = combinator ? function (a, b) {\n      return combinator(b, a);\n    } : id2;\n    return combine([active], [passive], _combinator).setName(passive, 'sampledBy');\n  }\n\n  var mixin$27 = {\n    _handlePrimaryValue: function (x) {\n      if (this._lastSecondary !== NOTHING) {\n        this._emitValue(x);\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (this._lastSecondary === NOTHING) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$35 = createStream$1('skipUntilBy', mixin$27);\n  var P$30 = createProperty$1('skipUntilBy', mixin$27);\n\n  function skipUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$35, P$30))(primary, secondary);\n  }\n\n  var mixin$28 = {\n    _handleSecondaryValue: function () {\n      this._emitEnd();\n    }\n  };\n\n  var S$36 = createStream$1('takeUntilBy', mixin$28);\n  var P$31 = createProperty$1('takeUntilBy', mixin$28);\n\n  function takeUntilBy(primary, secondary) {\n    return new (primary._ofSameType(S$36, P$31))(primary, secondary);\n  }\n\n  var mixin$29 = {\n    _init: function () {\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$flushOnEnd = _ref.flushOnEnd;\n      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _onActivation: function () {\n      this._primary.onAny(this._$handlePrimaryAny);\n      if (this._alive && this._secondary !== null) {\n        this._secondary.onAny(this._$handleSecondaryAny);\n      }\n    },\n    _handlePrimaryValue: function (x) {\n      this._buff.push(x);\n    },\n    _handleSecondaryValue: function () {\n      this._flush();\n    },\n    _handleSecondaryEnd: function () {\n      if (!this._flushOnEnd) {\n        this._emitEnd();\n      }\n    }\n  };\n\n  var S$37 = createStream$1('bufferBy', mixin$29);\n  var P$32 = createProperty$1('bufferBy', mixin$29);\n\n  function bufferBy(primary, secondary, options /* optional */) {\n    return new (primary._ofSameType(S$37, P$32))(primary, secondary, options);\n  }\n\n  var mixin$30 = {\n    _init: function () {\n      var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n      var _ref$flushOnEnd = _ref.flushOnEnd;\n      var flushOnEnd = _ref$flushOnEnd === undefined ? true : _ref$flushOnEnd;\n      var _ref$flushOnChange = _ref.flushOnChange;\n      var flushOnChange = _ref$flushOnChange === undefined ? false : _ref$flushOnChange;\n\n      this._buff = [];\n      this._flushOnEnd = flushOnEnd;\n      this._flushOnChange = flushOnChange;\n    },\n    _free: function () {\n      this._buff = null;\n    },\n    _flush: function () {\n      if (this._buff !== null) {\n        this._emitValue(this._buff);\n        this._buff = [];\n      }\n    },\n    _handlePrimaryEnd: function () {\n      if (this._flushOnEnd) {\n        this._flush();\n      }\n      this._emitEnd();\n    },\n    _handlePrimaryValue: function (x) {\n      this._buff.push(x);\n      if (this._lastSecondary !== NOTHING && !this._lastSecondary) {\n        this._flush();\n      }\n    },\n    _handleSecondaryEnd: function () {\n      if (!this._flushOnEnd && (this._lastSecondary === NOTHING || this._lastSecondary)) {\n        this._emitEnd();\n      }\n    },\n    _handleSecondaryValue: function (x) {\n      if (this._flushOnChange && !x) {\n        this._flush();\n      }\n\n      // from default _handleSecondaryValue\n      this._lastSecondary = x;\n    }\n  };\n\n  var S$38 = createStream$1('bufferWhileBy', mixin$30);\n  var P$33 = createProperty$1('bufferWhileBy', mixin$30);\n\n  function bufferWhileBy(primary, secondary, options /* optional */) {\n    return new (primary._ofSameType(S$38, P$33))(primary, secondary, options);\n  }\n\n  var f = function () {\n    return false;\n  };\n  var t = function () {\n    return true;\n  };\n\n  function awaiting(a, b) {\n    var result = merge([map$1(a, t), map$1(b, f)]);\n    result = skipDuplicates(result);\n    result = toProperty(result, f);\n    return result.setName(a, 'awaiting');\n  }\n\n  var mixin$31 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleValue: function (x) {\n      var fn = this._fn;\n      var result = fn(x);\n      if (result.convert) {\n        this._emitError(result.error);\n      } else {\n        this._emitValue(x);\n      }\n    }\n  };\n\n  var S$39 = createStream('valuesToErrors', mixin$31);\n  var P$34 = createProperty('valuesToErrors', mixin$31);\n\n  var defFn = function (x) {\n    return { convert: true, error: x };\n  };\n\n  function valuesToErrors(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn : arguments[1];\n\n    return new (obs._ofSameType(S$39, P$34))(obs, { fn: fn });\n  }\n\n  var mixin$32 = {\n    _init: function (_ref) {\n      var fn = _ref.fn;\n\n      this._fn = fn;\n    },\n    _free: function () {\n      this._fn = null;\n    },\n    _handleError: function (x) {\n      var fn = this._fn;\n      var result = fn(x);\n      if (result.convert) {\n        this._emitValue(result.value);\n      } else {\n        this._emitError(x);\n      }\n    }\n  };\n\n  var S$40 = createStream('errorsToValues', mixin$32);\n  var P$35 = createProperty('errorsToValues', mixin$32);\n\n  var defFn$1 = function (x) {\n    return { convert: true, value: x };\n  };\n\n  function errorsToValues(obs) {\n    var fn = arguments.length <= 1 || arguments[1] === undefined ? defFn$1 : arguments[1];\n\n    return new (obs._ofSameType(S$40, P$35))(obs, { fn: fn });\n  }\n\n  var mixin$33 = {\n    _handleError: function (x) {\n      this._emitError(x);\n      this._emitEnd();\n    }\n  };\n\n  var S$41 = createStream('endOnError', mixin$33);\n  var P$36 = createProperty('endOnError', mixin$33);\n\n  function endOnError(obs) {\n    return new (obs._ofSameType(S$41, P$36))(obs);\n  }\n\n  Observable.prototype.toProperty = function (fn) {\n    return toProperty(this, fn);\n  };\n\n  Observable.prototype.changes = function () {\n    return changes(this);\n  };\n\n  Observable.prototype.toPromise = function (Promise) {\n    return toPromise(this, Promise);\n  };\n\n  Observable.prototype.toESObservable = toESObservable;\n  Observable.prototype[symbol_('observable')] = toESObservable;\n\n  Observable.prototype.map = function (fn) {\n    return map$1(this, fn);\n  };\n\n  Observable.prototype.filter = function (fn) {\n    return filter(this, fn);\n  };\n\n  Observable.prototype.take = function (n) {\n    return take(this, n);\n  };\n\n  Observable.prototype.takeErrors = function (n) {\n    return takeErrors(this, n);\n  };\n\n  Observable.prototype.takeWhile = function (fn) {\n    return takeWhile(this, fn);\n  };\n\n  Observable.prototype.last = function () {\n    return last(this);\n  };\n\n  Observable.prototype.skip = function (n) {\n    return skip(this, n);\n  };\n\n  Observable.prototype.skipWhile = function (fn) {\n    return skipWhile(this, fn);\n  };\n\n  Observable.prototype.skipDuplicates = function (fn) {\n    return skipDuplicates(this, fn);\n  };\n\n  Observable.prototype.diff = function (fn, seed) {\n    return diff(this, fn, seed);\n  };\n\n  Observable.prototype.scan = function (fn, seed) {\n    return scan(this, fn, seed);\n  };\n\n  Observable.prototype.flatten = function (fn) {\n    return flatten(this, fn);\n  };\n\n  Observable.prototype.delay = function (wait) {\n    return delay(this, wait);\n  };\n\n  Observable.prototype.throttle = function (wait, options) {\n    return throttle(this, wait, options);\n  };\n\n  Observable.prototype.debounce = function (wait, options) {\n    return debounce(this, wait, options);\n  };\n\n  Observable.prototype.mapErrors = function (fn) {\n    return mapErrors(this, fn);\n  };\n\n  Observable.prototype.filterErrors = function (fn) {\n    return filterErrors(this, fn);\n  };\n\n  Observable.prototype.ignoreValues = function () {\n    return ignoreValues(this);\n  };\n\n  Observable.prototype.ignoreErrors = function () {\n    return ignoreErrors(this);\n  };\n\n  Observable.prototype.ignoreEnd = function () {\n    return ignoreEnd(this);\n  };\n\n  Observable.prototype.beforeEnd = function (fn) {\n    return beforeEnd(this, fn);\n  };\n\n  Observable.prototype.slidingWindow = function (max, min) {\n    return slidingWindow(this, max, min);\n  };\n\n  Observable.prototype.bufferWhile = function (fn, options) {\n    return bufferWhile(this, fn, options);\n  };\n\n  Observable.prototype.bufferWithCount = function (count, options) {\n    return bufferWhile$1(this, count, options);\n  };\n\n  Observable.prototype.bufferWithTimeOrCount = function (wait, count, options) {\n    return bufferWithTimeOrCount(this, wait, count, options);\n  };\n\n  Observable.prototype.transduce = function (transducer) {\n    return transduce(this, transducer);\n  };\n\n  Observable.prototype.withHandler = function (fn) {\n    return withHandler(this, fn);\n  };\n\n  Observable.prototype.combine = function (other, combinator) {\n    return combine([this, other], combinator);\n  };\n\n  Observable.prototype.zip = function (other, combinator) {\n    return zip([this, other], combinator);\n  };\n\n  Observable.prototype.merge = function (other) {\n    return merge([this, other]);\n  };\n\n  Observable.prototype.concat = function (other) {\n    return concat$1([this, other]);\n  };\n\n  var pool = function () {\n    return new Pool();\n  };\n\n  Observable.prototype.flatMap = function (fn) {\n    return new FlatMap(this, fn).setName(this, 'flatMap');\n  };\n  Observable.prototype.flatMapLatest = function (fn) {\n    return new FlatMap(this, fn, { concurLim: 1, drop: 'old' }).setName(this, 'flatMapLatest');\n  };\n  Observable.prototype.flatMapFirst = function (fn) {\n    return new FlatMap(this, fn, { concurLim: 1 }).setName(this, 'flatMapFirst');\n  };\n  Observable.prototype.flatMapConcat = function (fn) {\n    return new FlatMap(this, fn, { queueLim: -1, concurLim: 1 }).setName(this, 'flatMapConcat');\n  };\n  Observable.prototype.flatMapConcurLimit = function (fn, limit) {\n    return new FlatMap(this, fn, { queueLim: -1, concurLim: limit }).setName(this, 'flatMapConcurLimit');\n  };\n\n  Observable.prototype.flatMapErrors = function (fn) {\n    return new FlatMapErrors(this, fn).setName(this, 'flatMapErrors');\n  };\n\n  Observable.prototype.filterBy = function (other) {\n    return filterBy(this, other);\n  };\n\n  Observable.prototype.sampledBy = function (other, combinator) {\n    return sampledBy(this, other, combinator);\n  };\n\n  Observable.prototype.skipUntilBy = function (other) {\n    return skipUntilBy(this, other);\n  };\n\n  Observable.prototype.takeUntilBy = function (other) {\n    return takeUntilBy(this, other);\n  };\n\n  Observable.prototype.bufferBy = function (other, options) {\n    return bufferBy(this, other, options);\n  };\n\n  Observable.prototype.bufferWhileBy = function (other, options) {\n    return bufferWhileBy(this, other, options);\n  };\n\n  // Deprecated\n  // -----------------------------------------------------------------------------\n\n  function warn(msg) {\n    if (Kefir.DEPRECATION_WARNINGS !== false && console && typeof console.warn === 'function') {\n      var msg2 = '\\nHere is an Error object for you containing the call stack:';\n      console.warn(msg, msg2, new Error());\n    }\n  }\n\n  Observable.prototype.awaiting = function (other) {\n    warn('You are using deprecated .awaiting() method, see https://github.com/rpominov/kefir/issues/145');\n    return awaiting(this, other);\n  };\n\n  Observable.prototype.valuesToErrors = function (fn) {\n    warn('You are using deprecated .valuesToErrors() method, see https://github.com/rpominov/kefir/issues/149');\n    return valuesToErrors(this, fn);\n  };\n\n  Observable.prototype.errorsToValues = function (fn) {\n    warn('You are using deprecated .errorsToValues() method, see https://github.com/rpominov/kefir/issues/149');\n    return errorsToValues(this, fn);\n  };\n\n  Observable.prototype.endOnError = function () {\n    warn('You are using deprecated .endOnError() method, see https://github.com/rpominov/kefir/issues/150');\n    return endOnError(this);\n  };\n\n  // Exports\n  // --------------------------------------------------------------------------\n\n  var Kefir = { Observable: Observable, Stream: Stream, Property: Property, never: never, later: later, interval: interval, sequentially: sequentially,\n    fromPoll: fromPoll, withInterval: withInterval, fromCallback: fromCallback, fromNodeCallback: fromNodeCallback, fromEvents: fromEvents, stream: stream,\n    constant: constant, constantError: constantError, fromPromise: fromPromise, fromESObservable: fromESObservable, combine: combine, zip: zip, merge: merge,\n    concat: concat$1, Pool: Pool, pool: pool, repeat: repeat };\n\n  Kefir.Kefir = Kefir;\n\n  exports.Kefir = Kefir;\n  exports.Observable = Observable;\n  exports.Stream = Stream;\n  exports.Property = Property;\n  exports.never = never;\n  exports.later = later;\n  exports.interval = interval;\n  exports.sequentially = sequentially;\n  exports.fromPoll = fromPoll;\n  exports.withInterval = withInterval;\n  exports.fromCallback = fromCallback;\n  exports.fromNodeCallback = fromNodeCallback;\n  exports.fromEvents = fromEvents;\n  exports.stream = stream;\n  exports.constant = constant;\n  exports.constantError = constantError;\n  exports.fromPromise = fromPromise;\n  exports.fromESObservable = fromESObservable;\n  exports.combine = combine;\n  exports.zip = zip;\n  exports.merge = merge;\n  exports.concat = concat$1;\n  exports.Pool = Pool;\n  exports.pool = pool;\n  exports.repeat = repeat;\n  exports['default'] = Kefir;\n\n}));\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/kefir/dist/kefir.js\n ** module id = 56\n ** module chunks = 0\n **/\n//# sourceURL=./~/kefir/dist/kefir.js");

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = view;\n\nvar _virtualDom = __webpack_require__(1);\n\nvar _view = __webpack_require__(58);\n\nvar _view2 = _interopRequireDefault(_view);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Projectile = function Projectile(_ref) {\n  var width = _ref.width;\n  var height = _ref.height;\n  return function (_ref2) {\n    var x = _ref2.x;\n    var y = _ref2.y;\n    var id = _ref2.id;\n\n    var cannonWidth_ = parseInt(_view.cannonWidth, 10);\n    var cannonHeight_ = parseInt(_view.cannonHeight, 10);\n\n    var projectileX = cannonWidth_ / 2 + 'px + (' + x / 100 + ' * (' + width + 'px - ' + cannonWidth_ + 'px))';\n    var projectileY = height + 'px - (' + cannonHeight_ + 'px + (' + y / 100 + ' * ' + (height - cannonHeight_) + 'px))';\n\n    return (0, _virtualDom.h)(\n      'div',\n      {\n        key: id,\n        className: _view2.default.projectile,\n        style: {\n          transform: 'translate(calc(' + projectileX + '), calc(' + projectileY + '))'\n        } },\n      []\n    );\n  };\n};\n\nvar Invader = function Invader(_ref3) {\n  var width = _ref3.width;\n  var height = _ref3.height;\n  return function (_ref4) {\n    var type = _ref4.type;\n    var x = _ref4.x;\n    var y = _ref4.y;\n    var area = _ref4.area;\n\n    var invaderWidth = width * (area / 100);\n    var leftEdge = x / 100 * width - invaderWidth / 2;\n    return (0, _virtualDom.h)(\n      'div',\n      {\n        className: _view2.default[type + 'Invader'],\n        style: {\n          width: invaderWidth + 'px',\n          height: '50px',\n          left: leftEdge + 'px',\n          bottom: y / 100 * height + 'px'\n        } },\n      []\n    );\n  };\n};\n\nvar Score = function Score(score) {\n  return (0, _virtualDom.h)(\n    'div',\n    { className: _view2.default.score },\n    [(0, _virtualDom.h)(\n      'p',\n      { className: _view2.default.scoreText },\n      ['Score ', (0, _virtualDom.h)(\n        'span',\n        { className: _view2.default.scoreValue },\n        [score]\n      )]\n    )]\n  );\n};\n\nvar Lives = function Lives(lives) {\n  return (0, _virtualDom.h)(\n    'div',\n    { className: _view2.default.lives },\n    [(0, _virtualDom.h)(\n      'p',\n      { className: _view2.default.scoreText },\n      ['Lives ', (0, _virtualDom.h)(\n        'span',\n        { className: _view2.default.scoreValue },\n        [lives]\n      )]\n    )]\n  );\n};\n\nfunction view(_ref5) {\n  var dimensions = _ref5.dimensions;\n  var cannon = _ref5.cannon;\n  var _ref5$cannonProjectil = _ref5.cannonProjectiles;\n  var cannonProjectiles = _ref5$cannonProjectil === undefined ? [] : _ref5$cannonProjectil;\n  var invaders = _ref5.invaders;\n  var score = _ref5.score;\n\n  var cannonX = cannon.x / 100 + ' * (' + dimensions.width + 'px - ' + _view.cannonWidth + ')';\n  var gameOver = invaders.length === 0;\n  return (0, _virtualDom.h)(\n    'div',\n    { className: _view2.default.game },\n    [Score(score), Lives(cannon.lives), (0, _virtualDom.h)(\n      'div',\n      {\n        className: _view2.default.cannon,\n        style: { transform: 'translateX(calc(' + cannonX + '))' } },\n      []\n    ), cannonProjectiles.map(Projectile(dimensions)), invaders.map(Invader(dimensions)), gameOver ? (0, _virtualDom.h)(\n      'h1',\n      { className: _view2.default.endScreen },\n      ['Game Over']\n    ) : null]\n  );\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/view.js\n ** module id = 57\n ** module chunks = 0\n **/\n//# sourceURL=./src/view.js");

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(59);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(61)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../node_modules/css-loader/index.js?modules!./../node_modules/postcss-loader/index.js!./view.css\", function() {\n\t\t\tvar newContent = require(\"!!./../node_modules/css-loader/index.js?modules!./../node_modules/postcss-loader/index.js!./view.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/view.css\n ** module id = 58\n ** module chunks = 0\n **/\n//# sourceURL=./src/view.css");

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(60)();\n// imports\n\n\n// module\nexports.push([module.id, \"* { margin: 0; padding: 0 }\\n\\n@font-face {\\n\\tfont-family: \\\"04b03\\\";\\n\\tsrc: url(\\\"/assets/04b03.eot\\\");\\n\\tsrc: url(\\\"/assets/04b03.eot?#iefix\\\") format(\\\"embedded-opentype\\\"),\\n\\t\\turl(\\\"/assets/04b03.woff2\\\") format(\\\"woff2\\\"),\\n\\t\\turl(\\\"/assets/04b03.woff\\\") format(\\\"woff\\\"),\\n\\t\\turl(\\\"/assets/04b03.ttf\\\") format(\\\"truetype\\\");\\n\\tfont-weight: normal;\\n\\tfont-style: normal;\\n}\\n\\n:root,\\n.app,\\n.lfeT2t1nSDOa5v5wE0TAX {\\n  width: 100%;\\n  height: 100%;\\n}\\n\\n.lfeT2t1nSDOa5v5wE0TAX {\\n  position: relative;\\n  background: #000;\\n  overflow: hidden;\\n}\\n\\n._3SSeOfm46eqMVG4XaXlaFN {\\n  position: absolute;\\n  bottom: 0;\\n  width: 50px;\\n  height: 50px;\\n  background: url(/assets/cannon.svg) no-repeat bottom left;\\n  background-size: contain;\\n}\\n\\n._1NEPwxbmzlpdzCYkjNsBb4 {\\n  position: absolute;\\n  width: 1px;\\n  height: 15px;\\n  background: red;\\n}\\n\\n._3ASirH3Vk2eD7p7fHudyU4 {\\n  display: block;\\n  position: absolute;\\n}\\n\\n.femTINsZvnoRrej6PmEPD {\\n  background: white;\\n}\\n\\n._2UKgeXyZY6jc8ZNYP__wmC {\\n  background: white;\\n}\\n\\n._2Xtu423B0J6wUvDdAO-5kD {\\n  background: white;\\n}\\n\\n.MFAJcVu8kBJWGeK7F2912 {\\n  position: absolute;\\n  left: 20px;\\n  top: 20px;\\n}\\n\\n._3Wpfq8Nn4T_Dmi0NwnCQZe {\\n  position: absolute;\\n  top: 20px;\\n  right: 20px;\\n}\\n\\n._1rKNoI--Hyj38cs9hNsATJ {\\n  font-family: \\\"04b03\\\";\\n  font-size: 30px;\\n  color: #fff;\\n}\\n\\n.nXu1J2SX66rP_WmInOqW0 {\\n  color: #22ea22;\\n}\\n\\n._1Kp499bK9YUmMJFYmbURWM {\\n  position: fixed;\\n  left: 50%;\\n  top: 50%;\\n  -webkit-transform: translate(-50%, -50%);\\n          transform: translate(-50%, -50%);\\n  text-transform: uppercase;\\n  color: #da5151;\\n  font-family: \\\"04b03\\\";\\n  font-size: 120px;\\n  padding: 0;\\n  margin: 0;\\n  width: 100%;\\n  text-align: center;\\n  font-weight: 100;\\n}\\n\", \"\"]);\n\n// exports\nexports.locals = {\n\t\"cannonWidth\": \"50px\",\n\t\"cannonHeight\": \"50px\",\n\t\"invaderWidth\": \"var(--invaderWidth)\",\n\t\"invaderHeight\": \"var(--invaderHeight)\",\n\t\"game\": \"lfeT2t1nSDOa5v5wE0TAX\",\n\t\"cannon\": \"_3SSeOfm46eqMVG4XaXlaFN\",\n\t\"projectile\": \"_1NEPwxbmzlpdzCYkjNsBb4\",\n\t\"invader\": \"_3ASirH3Vk2eD7p7fHudyU4\",\n\t\"smallInvader\": \"femTINsZvnoRrej6PmEPD _3ASirH3Vk2eD7p7fHudyU4\",\n\t\"mediumInvader\": \"_2UKgeXyZY6jc8ZNYP__wmC _3ASirH3Vk2eD7p7fHudyU4\",\n\t\"largeInvader\": \"_2Xtu423B0J6wUvDdAO-5kD _3ASirH3Vk2eD7p7fHudyU4\",\n\t\"score\": \"MFAJcVu8kBJWGeK7F2912\",\n\t\"lives\": \"_3Wpfq8Nn4T_Dmi0NwnCQZe\",\n\t\"scoreText\": \"_1rKNoI--Hyj38cs9hNsATJ\",\n\t\"scoreValue\": \"nXu1J2SX66rP_WmInOqW0\",\n\t\"endScreen\": \"_1Kp499bK9YUmMJFYmbURWM\"\n};\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader?modules!./~/postcss-loader!./src/view.css\n ** module id = 59\n ** module chunks = 0\n **/\n//# sourceURL=./src/view.css");

/***/ },
/* 60 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 60\n ** module chunks = 0\n **/\n//# sourceURL=./~/css-loader/lib/css-base.js");

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(false) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 61\n ** module chunks = 0\n **/\n//# sourceURL=./~/style-loader/addStyles.js");

/***/ }
/******/ ]);